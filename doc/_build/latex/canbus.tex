%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{canbus}
\date{Oct 14, 2024}
\release{1.0}
\author{Jan Jansen}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{intro:introduction}}\label{\detokenize{intro::doc}}
\sphinxAtStartPar
I have an old volvo, and although this is probably a bad indicator for a car enthusiast, I do like car technology.

\sphinxAtStartPar
Cars have evolved, and are now full of electronics. Microcontrollers interconnected via a CAN netwerk.

\sphinxAtStartPar
Very soon my old diesel car will not be legal anymore (although EURO 5, having a particle filter, EGR valve ….)

\sphinxAtStartPar
The value of my car was estimated 500 euro, and this was two years ago …

\sphinxAtStartPar
Still, for me it is much more valuable! Certainly since I started looking under the hood.

\sphinxAtStartPar
I bought one of those cheap chinese diagnostic tools.
At first I did not pay attention, since all I wanted is save a buck on maintenance. This is one of the reasons old cars get expensive and people will get a new one.

\sphinxAtStartPar
The diagnostic tool is called VIDA, it came with a virtual box.
As it happens you can find this easily: e.g. \sphinxurl{https://volvodiag.com/product/virtualbox-build/}  (google is your friend)

\sphinxAtStartPar
This is commercial software, so any free copy you will find is of course illegal. From what I found out somebody (Gunnar?) in the US made a copy.

\sphinxAtStartPar
Suppose you’re a volvo dealer, you would like to use the same software for all your volvo models, even the older ones.

\sphinxAtStartPar
The software is using an sql\sphinxhyphen{}database and XML files, so everything is a parameter. I’m not an expert, but it is very well made, and offers a lot of insight on how professional developers create a highly configurable package.
Watch and learn!

\sphinxAtStartPar
A word of warning : the software is not open sourced!

\sphinxAtStartPar
Instead of buying a new electric volvo my attention got caught by Damien Maguire MuskVo. He is involved in the openinverter project : \sphinxurl{https://openinverter.org/wiki/Main\_Page}.

\sphinxAtStartPar
As it turns out these car enthusiasts have succesfully converted modern (ecu containing) cars into electric vehicles with modern electrics and batteries.

\sphinxAtStartPar
A big hurdle is exactly the presence of all the electronics. If replacing the ICE (internal combustion engine) by electric, you will somehow have to fool the brain (ECM) that the ICE is still there.

\sphinxAtStartPar
All these modules talk to each other via the CAN bus network. An important step in an EV conversion is getting familiar with this network.

\sphinxAtStartPar
I created a cheap STM32 CAN interface, which consists of an advanced sniffer/sender and an emulator (which will eventually emulate the Volvo ECM)

\sphinxAtStartPar
As you might have guessed Car manufacturers are not really into open source. Even figuring out what is going on the CANBUS can be challenging. This is the reason why I analysed the diagnostic software, to gain further insight into CAN messaging.

\sphinxAtStartPar
This manual is an account of my journey in the car network, car communication and car diagnostics, which might pave the way for an EV conversion….


\chapter{Volvo CANBUS and Modules}
\label{\detokenize{canbus/index:volvo-canbus-and-modules}}\label{\detokenize{canbus/index::doc}}

\section{Volvo Canbus OBD2}
\label{\detokenize{canbus/volvo-canbus:volvo-canbus-obd2}}\label{\detokenize{canbus/volvo-canbus::doc}}
\noindent\sphinxincludegraphics{{can-hs-ls}.png}


\section{Networks}
\label{\detokenize{canbus/networks:networks}}\label{\detokenize{canbus/networks::doc}}
\noindent\sphinxincludegraphics{{networks}.png}

\sphinxAtStartPar
Controller Area Network (CAN) emerged as a communication network by Bosch GmbH specifically tailored for the automotive industry in 1985. It operates on a message\sphinxhyphen{}based broadcast protocol.

\sphinxAtStartPar
Given its maximum bandwidth of 1 Mbit/s, CAN proves inadequate for transferring video and audio data. Hence, Media Oriented Systems Transport (MOST) serves this purpose . MOST, a fiber\sphinxhyphen{}optic ring network, is meticulously engineered for the efficient transmission of large data volumes within automotive systems. Nodes within a MOST network aren’t directly accessible; they are only reachable via specialized CAN ECUs functioning as gateways.

\sphinxAtStartPar
To alleviate CAN’s load, Local Interconnect Network (LIN) establishes a sub\sphinxhyphen{}network on CAN for communicating with low\sphinxhyphen{}performance ECUs. Access to LIN is orchestrated through the CAN master node, which oversees slave nodes within this network.


\section{Volvo V50 modules overview}
\label{\detokenize{canbus/volvo-modules:volvo-v50-modules-overview}}\label{\detokenize{canbus/volvo-modules::doc}}
\sphinxAtStartPar
This is an overview of the modules in a volvo V50.

\sphinxAtStartPar
in the vida software you can find an overview that looks like this :

\noindent\sphinxincludegraphics{{modules-overview}.png}

\sphinxAtStartPar
in the log of the diagnostic session I found a link between:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the vida xml module ID

\item {} 
\sphinxAtStartPar
the can message ID ? (to be confirmed)

\item {} 
\sphinxAtStartPar
the module description

\end{itemize}

\noindent\sphinxincludegraphics{{module-id}.png}


\section{Modules:}
\label{\detokenize{canbus/volvo-modules:modules}}\begin{itemize}
\item {} 
\sphinxAtStartPar
CEM     Central Electronic Module (Behind right side of dash)

\item {} 
\sphinxAtStartPar
EPS     Electrical Power Steering module (Right front corner of engine compt)

\item {} 
\sphinxAtStartPar
BCM     Brake Control Module (At left rear corner of engine compt)

\item {} 
\sphinxAtStartPar
HCM     Headlamp Control Module (Behind left headlight) (Active lights only, (S40/V50))

\item {} 
\sphinxAtStartPar
SWM     Steering Wheel Module (Top of steering column)

\item {} 
\sphinxAtStartPar
ECM     Engine Control Module (Left front of engine compt)

\item {} 
\sphinxAtStartPar
TCM     Transmission Control Module (Rear of engine compt) (Automatic transmission only)

\item {} 
\sphinxAtStartPar
ADM     Additive Dosing Module (Diesel only)

\end{itemize}


\section{overview modules}
\label{\detokenize{canbus/modules:overview-modules}}\label{\detokenize{canbus/modules::doc}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Number
&\sphinxstyletheadfamily 
\sphinxAtStartPar
ID
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
\\
\hline
\sphinxAtStartPar
254501
&
\sphinxAtStartPar
11
&
\sphinxAtStartPar
ADM
\\
\hline
\sphinxAtStartPar
366902
&
\sphinxAtStartPar
99
&
\sphinxAtStartPar
PAM
\\
\hline
\sphinxAtStartPar
284101
&
\sphinxAtStartPar
17
&
\sphinxAtStartPar
ECM
\\
\hline
\sphinxAtStartPar
366901
&
\sphinxAtStartPar
45
&
\sphinxAtStartPar
KVM
\\
\hline
\sphinxAtStartPar
372301
&
\sphinxAtStartPar
82
&
\sphinxAtStartPar
AEM
\\
\hline
\sphinxAtStartPar
372302
&
\sphinxAtStartPar
80
&
\sphinxAtStartPar
CEM
\\
\hline
\sphinxAtStartPar
372304
&
\sphinxAtStartPar
64
&
\sphinxAtStartPar
CEM
\\
\hline
\sphinxAtStartPar
381101
&
\sphinxAtStartPar
81
&
\sphinxAtStartPar
DIM
\\
\hline
\sphinxAtStartPar
393202
&
\sphinxAtStartPar
109
&
\sphinxAtStartPar
AUD
\\
\hline
\sphinxAtStartPar
393901
&
\sphinxAtStartPar
84
&
\sphinxAtStartPar
ICM
\\
\hline
\sphinxAtStartPar
393906
&
\sphinxAtStartPar
102
&
\sphinxAtStartPar
MMM
\\
\hline
\sphinxAtStartPar
394201
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
PHM
\\
\hline
\sphinxAtStartPar
395301
&
\sphinxAtStartPar
104
&
\sphinxAtStartPar
SUB
\\
\hline
\sphinxAtStartPar
593102
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
BCM
\\
\hline
\sphinxAtStartPar
641901
&
\sphinxAtStartPar
73
&
\sphinxAtStartPar
SWM
\\
\hline
\sphinxAtStartPar
645901
&
\sphinxAtStartPar
48
&
\sphinxAtStartPar
EPS
\\
\hline
\sphinxAtStartPar
831701
&
\sphinxAtStartPar
67
&
\sphinxAtStartPar
DDM
\\
\hline
\sphinxAtStartPar
831703
&
\sphinxAtStartPar
69
&
\sphinxAtStartPar
PDM
\\
\hline
\sphinxAtStartPar
852601
&
\sphinxAtStartPar
46
&
\sphinxAtStartPar
PSM
\\
\hline
\sphinxAtStartPar
871101
&
\sphinxAtStartPar
41
&
\sphinxAtStartPar
CCM
\\
\hline
\sphinxAtStartPar
875401
&
\sphinxAtStartPar
24
&
\sphinxAtStartPar
CPM
\\
\hline
\sphinxAtStartPar
884701
&
\sphinxAtStartPar
88
&
\sphinxAtStartPar
SRS
\\
\hline
\sphinxAtStartPar
892901
&
\sphinxAtStartPar
35
&
\sphinxAtStartPar
TRM
\\
\hline
\sphinxAtStartPar
393204
&
\sphinxAtStartPar
117
&
\sphinxAtStartPar
IAM
\\
\hline
\sphinxAtStartPar
393205
&
\sphinxAtStartPar
113
&
\sphinxAtStartPar
RDAR
\\
\hline
\sphinxAtStartPar
372306
&
\sphinxAtStartPar
123
&
\sphinxAtStartPar
AUU
\\
\hline
\sphinxAtStartPar
352902
&
\sphinxAtStartPar
112
&
\sphinxAtStartPar
HCM
\\
\hline
\sphinxAtStartPar
394202
&
\sphinxAtStartPar
124
&
\sphinxAtStartPar
BPM
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Modules for profile}
\label{\detokenize{canbus/ecutabel:modules-for-profile}}\label{\detokenize{canbus/ecutabel::doc}}
\sphinxAtStartPar
In the file : /system/log/diagnostics/VIDA, is a lot of usefull info.

\sphinxAtStartPar
For instance : vadis\_GetallEcuDataForProfile 0b00c8af83f1a8fb.


\subsection{executing stored procedure}
\label{\detokenize{canbus/ecutabel:executing-stored-procedure}}\begin{description}
\item[{SELECT  DISTINCT}] \leavevmode\begin{quote}

\sphinxAtStartPar
t121.commaddress as ecuaddress,
t123.identifier as busid,
t102.identifier as ecutype,
t102.description ecuDescription,
t100.identifier diagnosticnumber,
t121.id as configId,
t121.canidrx as canid,
t121.fkT121\_Config\_Gateway as gatewayConfigId,
t122.id as protocolid,
t161.folderLevel as folderLevel,
t121.priority as {[}priority{]}
\end{quote}

\sphinxAtStartPar
FROM      T120\_Config\_EcuVariant t120
INNER JOIN
\begin{quote}

\sphinxAtStartPar
T121\_Config T121 ON T120.fkT121\_Config = T121.id
\end{quote}
\begin{description}
\item[{INNER JOIN}] \leavevmode
\sphinxAtStartPar
T122\_Protocol T122 ON T121.fkT122\_protocol = T122.id

\item[{INNER JOIN}] \leavevmode
\sphinxAtStartPar
T100\_EcuVariant T100 ON T120.fkT100\_EcuVariant = T100.id

\item[{INNER JOIN}] \leavevmode
\sphinxAtStartPar
T160\_DefaultEcuVariant T160 ON T100.id = T160.fkT100\_EcuVariant

\item[{INNER JOIN}] \leavevmode
\sphinxAtStartPar
T161\_Profile T161 on T160.fkT161\_Profile = T161.Id

\item[{INNER JOIN}] \leavevmode
\sphinxAtStartPar
T123\_Bus t123 on T121.fkt123\_bus = t123.id

\item[{INNER JOIN}] \leavevmode
\sphinxAtStartPar
T101\_Ecu t101 on T100.fkt101\_ecu = t101.id

\item[{INNER JOIN}] \leavevmode
\sphinxAtStartPar
T102\_EcuType t102 on t101.fkt102\_ecutype = t102.id

\item[{INNER JOIN}] \leavevmode
\sphinxAtStartPar
dbo.GetCompatibleProfiles(‘0b00c8af83f1a8fb’) p on t161.id = p.id

\item[{WHERE}] \leavevmode
\sphinxAtStartPar
t102.identifier \textless{}\textgreater{} 0

\end{description}

\sphinxAtStartPar
ORDER BY t161.folderLevel DESC, t121.priority ASC

\end{description}


\subsection{table with overview}
\label{\detokenize{canbus/ecutabel:table-with-overview}}
\sphinxAtStartPar
“ecuaddress”,”busid”,”ecutype”,”ecuDescription”,
“diagnosticnumber”,”configId”,”gatewayConfigId”


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{EcuAddress for Model}\label{\detokenize{canbus/ecutabel:id1}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{1}{5}|\X{1}{5}|\X{2}{5}|\X{1}{5}|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Address
&\sphinxstyletheadfamily 
\sphinxAtStartPar
busid
&\sphinxstyletheadfamily 
\sphinxAtStartPar
ecutype
&\sphinxstyletheadfamily 
\sphinxAtStartPar
descript
\\
\hline
\sphinxAtStartPar
0B
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
254501
&
\sphinxAtStartPar
ADM
\\
\hline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
284101
&
\sphinxAtStartPar
ECM
\\
\hline
\sphinxAtStartPar
7B
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
372306
&
\sphinxAtStartPar
AUU
\\
\hline
\sphinxAtStartPar
7C
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
394202
&
\sphinxAtStartPar
BPM
\\
\hline
\sphinxAtStartPar
2D
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
366901
&
\sphinxAtStartPar
KVM
\\
\hline
\sphinxAtStartPar
63
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
366902
&
\sphinxAtStartPar
PAM
\\
\hline
\sphinxAtStartPar
52
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
372301
&
\sphinxAtStartPar
AEM
\\
\hline
\sphinxAtStartPar
40
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
372304
&
\sphinxAtStartPar
CEM
\\
\hline
\sphinxAtStartPar
51
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
381101
&
\sphinxAtStartPar
DIM
\\
\hline
\sphinxAtStartPar
6D
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
393202
&
\sphinxAtStartPar
AUD
\\
\hline
\sphinxAtStartPar
75
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
393204
&
\sphinxAtStartPar
IAM
\\
\hline
\sphinxAtStartPar
71
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
393205
&
\sphinxAtStartPar
RDAR
\\
\hline
\sphinxAtStartPar
54
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
393901
&
\sphinxAtStartPar
ICM
\\
\hline
\sphinxAtStartPar
66
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
393906
&
\sphinxAtStartPar
MMM
\\
\hline
\sphinxAtStartPar
64
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
394201
&
\sphinxAtStartPar
PHM
\\
\hline
\sphinxAtStartPar
68
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
395301
&
\sphinxAtStartPar
SUB
\\
\hline
\sphinxAtStartPar
43
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
831701
&
\sphinxAtStartPar
DDM
\\
\hline
\sphinxAtStartPar
45
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
831703
&
\sphinxAtStartPar
PDM
\\
\hline
\sphinxAtStartPar
2E
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
852601
&
\sphinxAtStartPar
PSM
\\
\hline
\sphinxAtStartPar
29
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
871101
&
\sphinxAtStartPar
CCM
\\
\hline
\sphinxAtStartPar
18
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
875401
&
\sphinxAtStartPar
CPM
\\
\hline
\sphinxAtStartPar
58
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
884701
&
\sphinxAtStartPar
SRS
\\
\hline
\sphinxAtStartPar
23
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
892901
&
\sphinxAtStartPar
TRM
\\
\hline
\sphinxAtStartPar
70
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
352902
&
\sphinxAtStartPar
HCM
\\
\hline
\sphinxAtStartPar
50
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
372302
&
\sphinxAtStartPar
CEM
\\
\hline
\sphinxAtStartPar
01
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
593102
&
\sphinxAtStartPar
BCM
\\
\hline
\sphinxAtStartPar
49
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
641901
&
\sphinxAtStartPar
SWM
\\
\hline
\sphinxAtStartPar
30
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
645901
&
\sphinxAtStartPar
EPS
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\section{further info on canbus:}
\label{\detokenize{canbus/webpage:further-info-on-canbus}}\label{\detokenize{canbus/webpage::doc}}

\section{Volvo uses extended identifiers:}
\label{\detokenize{canbus/webpage:volvo-uses-extended-identifiers}}
\sphinxAtStartPar
CAN frames follow a defined format: all standard frames have an 11\sphinxhyphen{}bit
identifier and up to 8 bytes of data. Extended frames allow 29 bit identifiers,
but only the same 8 bytes of data. CAN frames also include checksums, and most
CAN implementations in microcontrollers will automatically insert / verify
checksums in hardware.

\noindent\sphinxincludegraphics{{can_signalling}.png}

\noindent\sphinxincludegraphics{{can_frame}.png}

\noindent\sphinxincludegraphics{{filter_banks}.png}


\chapter{Volvo Diagnostic Software}
\label{\detokenize{software/index:volvo-diagnostic-software}}\label{\detokenize{software/index::doc}}

\section{Volvo VIDA}
\label{\detokenize{software/vida:volvo-vida}}\label{\detokenize{software/vida::doc}}
\sphinxAtStartPar
Volvo VIDA (Vehicle Information and Diagnostics for Aftersales) is a comprehensive diagnostic software system developed by Volvo Cars to aid in the servicing and maintenance of their vehicles. It provides technicians with the necessary tools to diagnose, troubleshoot, and repair Volvo cars effectively.


\subsection{Key Features}
\label{\detokenize{software/vida:key-features}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Vehicle Information}:
VIDA provides detailed information about Volvo vehicles, including technical specifications, wiring diagrams, component locations, and service procedures. This allows technicians to quickly access relevant information needed for diagnosis and repair.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Diagnostic Functions}:
VIDA allows technicians to perform comprehensive diagnostics on various vehicle systems, including the engine, transmission, ABS, airbag, climate control, and more. It can read and clear diagnostic trouble codes (DTCs), view live data streams, perform component tests, and program electronic control modules (ECUs).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Software Updates}:
VIDA enables technicians to update vehicle software to the latest available versions. This is crucial for ensuring optimal performance, reliability, and compatibility with new technologies.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Guided Diagnostics}:
VIDA offers guided diagnostic procedures to assist technicians in identifying and resolving vehicle issues efficiently. These step\sphinxhyphen{}by\sphinxhyphen{}step instructions help streamline the diagnostic process and minimize errors.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Remote Diagnostics}:
VIDA supports remote diagnostics capabilities, allowing technicians to access vehicle data and perform diagnostics remotely. This feature can be particularly useful for troubleshooting complex issues or providing support to technicians in remote locations.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Integrated Parts Catalog}:
VIDA includes an integrated parts catalog that provides access to genuine Volvo parts information, including part numbers, descriptions, and illustrations. This simplifies the process of ordering and replacing components during repairs.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Multi\sphinxhyphen{}Language Support}:
VIDA is available in multiple languages, making it accessible to technicians worldwide.

\end{enumerate}

\sphinxAtStartPar
Overall, Volvo VIDA is a powerful diagnostic tool that helps Volvo technicians efficiently diagnose and repair vehicles, ensuring optimal performance, safety, and reliability for Volvo owners.


\subsection{databases}
\label{\detokenize{software/vida:databases}}
\sphinxAtStartPar
The best way to get some relevant data out of the VIDA, is to start a diagnostic sessions. It then creates logfiles under : VIDA/system/log/diagnostics.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Trying to open a connection database server (Master DB)
 connection is open
Found database AccessServer
Found database BaseData
Found database CarCom
Found database DiagSwdlRepository
Found database DiagSwdlSession
Found database DiceTiming
Found database imagerepository
Found database EPC
\end{sphinxVerbatim}


\subsection{SQL database VIDA}
\label{\detokenize{software/vida:sql-database-vida}}
\sphinxAtStartPar
the VIDA installation has a SQL server database (microsoft) onboard.
There is a way to peek into the tables :
\sphinxhyphen{} in the VidaConfigApplication.exe
\sphinxhyphen{} DBUser :  sa  (in my case)
\sphinxhyphen{} DBpwd :  GunnarS3g3

\sphinxAtStartPar
SQL server import/export wizard
\sphinxhyphen{} use sql Server Authentication
\sphinxhyphen{} select the database (eg DiagSwdlSession)


\subsection{howto peek into the VIDA database:}
\label{\detokenize{software/vida:howto-peek-into-the-vida-database}}
\sphinxAtStartPar
Volvo VIDA software is designed for multiple Volvo models and multiple model years. To select your model and the appropriate configuration, it reads out the VIN (vehicle identification number). This is made possible by the software’s large database of XML files. There is a method to read out these XML files and select the ones that are important for your model.

\sphinxAtStartPar
\sphinxurl{https://github.com/spnda/volvo\_vida\_db}
\sphinxurl{https://github.com/Tigo2000/Volvo-VIDA/}


\subsection{stored procedures:}
\label{\detokenize{software/vida:stored-procedures}}
\sphinxAtStartPar
in the microsoft sql database, you can find stored procedures, that can give some indication on where VIDA gets its information

\begin{sphinxVerbatim}[commandchars=\\\{\}]
/****** Object:  Stored Procedure dbo.vadis\PYGZus{}GetDiagInit    Script Date: 2006\PYGZhy{}10\PYGZhy{}18 14:59:31 ******/

ALTER  PROCEDURE [dbo].[vadis\PYGZus{}GetDiagInit]
@configId int
AS
SELECT     T132\PYGZus{}InitValueType.name,
    T131\PYGZus{}InitValue.initValue
FROM
  T130\PYGZus{}Init
INNER JOIN
         T131\PYGZus{}InitValue ON T130\PYGZus{}Init.id = T131\PYGZus{}InitValue.fkT130\PYGZus{}Init
INNER JOIN
         T132\PYGZus{}InitValueType ON T131\PYGZus{}InitValue.fkT132\PYGZus{}InitValueType = T132\PYGZus{}InitValueType.id
INNER JOIN
  T121\PYGZus{}Config ON T130\PYGZus{}Init.id = T121\PYGZus{}Config.fkT130\PYGZus{}Init\PYGZus{}Diag
WHERE
 (T121\PYGZus{}Config.id = @configId)
\end{sphinxVerbatim}


\subsection{example:}
\label{\detokenize{software/vida:example}}
\sphinxAtStartPar
this could be a record of interest :
CEM,Central electronic module (CEM),Read high beam relay,NA,372302,80,0x504B03041400000008000B1D47
\begin{itemize}
\item {} 
\sphinxAtStartPar
the number 372302 refers to the CEM

\item {} 
\sphinxAtStartPar
0x504.. is a coded file

\end{itemize}


\section{GGD\sphinxhyphen{}DHA ( Generic Global Diagnostic \sphinxhyphen{} Diagnostic Host Application ) .}
\label{\detokenize{software/DHA:ggd-dha-generic-global-diagnostic-diagnostic-host-application}}\label{\detokenize{software/DHA::doc}}
\sphinxAtStartPar
“GGD DHA is a system used when developing systems in cars. This program contains all
variables that are transferred within the car. It can access all variables and commands allowing
reading and/or writing to these variables. It is also possible to read DTCs, part numbers,
upload new software to the different modules etc. This system is useful when testing new
systems since in VIDA you do not have access to all variables, which you have in GGD DHA,
but in GGD DHA you do not get access to the technical description of how you replace parts,
troubleshooting etc. However, in GGD DHA it is possible to create automatic sequences that
read or write to the variables making it unnecessary to be at the computer all the time. When
writing to a variable, it is possible to set the sensor values to the required values making it
possible to simulate different conditions in a car even if the conditions have not occurred.”

\sphinxAtStartPar
\sphinxurl{https://drive.google.com/file/d/1Guan662vouIs1bkY1W7K2SAEcnkzm8A0/view}

\sphinxAtStartPar
This software uses databases in (ddb or dds) format.
After opening, you can send individual messages.

\noindent\sphinxincludegraphics{{DHA}.png}

\sphinxAtStartPar
In the Volvo Diagnostic Host Application, you can save the data in text format.

\sphinxAtStartPar
Peeking in this database (P1005\_(D2)\_0520\_TO1\_050202.DDB) give some insight in how the Volvo Can messaging works.

\sphinxAtStartPar
This example is for reading the VIN number

\begin{sphinxVerbatim}[commandchars=\\\{\}]
DIAG\PYGZus{}ITEM [NAME=VIN][SEND\PYGZus{}ABLE=TRUE][NOTE=] [FORMAT=OTHER:2] [BASE=HEX] [VALUE=E9] [TYPE=BLOFF][INPUT=FALSE]
BEGIN
  RESPONSE\PYGZus{}ITEM [NAME=VIN .][SEND\PYGZus{}ABLE=FALSE][NOTE=VIN] [NO\PYGZus{}OF\PYGZus{}BYTES=17] [OFFSET=2] [MASK=] [UNIT=.] [PRECISION=0] [SIGNED=U] [BASE=ASCII] [FORMULA=*1] [COMP\PYGZus{}VALUE=] [DEP\PYGZus{}RESPITEM=CHECKOK] [DEP\PYGZus{}RESPITEM\PYGZus{}CHECK=TRUE]
END
\end{sphinxVerbatim}


\section{GGD\sphinxhyphen{}DHA (  Hacking \sphinxhyphen{} or modifying the database ).}
\label{\detokenize{software/DHA-hack:ggd-dha-hacking-or-modifying-the-database}}\label{\detokenize{software/DHA-hack::doc}}
\sphinxAtStartPar
This software uses databases in (ddb, dds) format.
The cool thing is that this software works with the DICE cable.
ddb database format is text format and can be edited.

\sphinxAtStartPar
I created a small database for working with my V50.
The CANBUS messages for the V50 can be found in the VIDA database/XML files.

\sphinxAtStartPar
I created a sample to interact with a stm32, so it sends a serial number upon request, pretending it is an ECM module (0x50).
(can be found under the stm32f103c6\sphinxhyphen{}canbus directory)


\subsection{conclusion :}
\label{\detokenize{software/DHA-hack:conclusion}}
\sphinxAtStartPar
this is an easy way to interact with all the modules in your car at no extra cost, provided you already have the DICE cable, and without programming, modifying the database in a texteditor will do.

\noindent\sphinxincludegraphics{{dha-hack}.png}


\chapter{Analysis of the MSQL VIDA database}
\label{\detokenize{vidadatabase/index:analysis-of-the-msql-vida-database}}\label{\detokenize{vidadatabase/index::doc}}

\section{Vida database analysis}
\label{\detokenize{vidadatabase/ecuvariant:vida-database-analysis}}\label{\detokenize{vidadatabase/ecuvariant::doc}}
\sphinxAtStartPar
The main focus is the CARCOM database. (since guess, here is the CAN messages get assembled or translated)

\sphinxAtStartPar
something key is the ecu\sphinxhyphen{}identification

\sphinxAtStartPar
As a starting point the diagnostic session was used.
Looking up 31254684 AC diagnosticPartNO in T100, gave EcuvariantID = 2013.
\begin{itemize}
\item {} 
\sphinxAtStartPar
it refers to T101 and from there to T102

\end{itemize}

\sphinxAtStartPar
so here I find identifier : 372302, CEM (this also is present in XML files)
Suppose this is the CEM under the glove box.
\begin{itemize}
\item {} 
\sphinxAtStartPar
T120 links to T121

\end{itemize}

\sphinxAtStartPar
Here if find “29” which refers to extended CANBUS ID

\noindent\sphinxincludegraphics{{ecuvariant}.png}


\section{Vida database analysis (block child)}
\label{\detokenize{vidadatabase/block:vida-database-analysis-block-child}}\label{\detokenize{vidadatabase/block::doc}}
\sphinxAtStartPar
The main focus is the CARCOM database.

\sphinxAtStartPar
T144 blockchild
\sphinxhyphen{} query with ID=2013 (ecuvariant)

\sphinxAtStartPar
quite a few fk141 blockchild ID (extract)

\sphinxAtStartPar
\sphinxstyleemphasis{guess these are all parameters from the CEM}
\begin{itemize}
\item {} 
\sphinxAtStartPar
4419201 Total distance (T141 block)

\item {} 
\sphinxAtStartPar
4419685 Global Data

\item {} 
\sphinxAtStartPar
4419034 Ambient Temperature

\end{itemize}


\subsection{example: T141 Ambient temperature}
\label{\detokenize{vidadatabase/block:example-t141-ambient-temperature}}
\sphinxAtStartPar
ID= 44119304
4419034 ambient temperature
\begin{itemize}
\item {} 
\sphinxAtStartPar
blocktype 5

\item {} 
\sphinxAtStartPar
fk143\_datatype 50

\item {} 
\sphinxAtStartPar
length 16

\end{itemize}

\sphinxAtStartPar
\sphinxhyphen{}\textgreater{} blocktype 5 = REID
\sphinxhyphen{}\textgreater{} datatype 50 = HEX


\subsection{example: T141 Accelerator pedal}
\label{\detokenize{vidadatabase/block:example-t141-accelerator-pedal}}
\sphinxAtStartPar
4419314 Accelerator pedal blocktype 5, fk143\_datatype 50, length 16

\noindent\sphinxincludegraphics{{block}.png}


\section{Carcommunication and scripts}
\label{\detokenize{vidadatabase/link-carcom-diagswdl:carcommunication-and-scripts}}\label{\detokenize{vidadatabase/link-carcom-diagswdl::doc}}
\sphinxAtStartPar
in the CARCOM database (T102), the modules are defined by a number:
example the CEM = 372302

\sphinxAtStartPar
\sphinxstylestrong{scripttype statusindentifier}

\sphinxAtStartPar
in the DIAGSWDL database (ScriptCarFunction), Functiongroup (372302 exactly the same number refers to numerous script numbers)

\sphinxAtStartPar
Example : 0900c8af81b6a712 which is SUN\_SENSOR,\_VOLTAGE,\_STATUS


\subsection{in the XML file :}
\label{\detokenize{vidadatabase/link-carcom-diagswdl:in-the-xml-file}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
property class=\PYGZdq{}Parameter\PYGZdq{} id=\PYGZdq{}nev9960842n1\PYGZhy{}nev9960863n1\PYGZdq{}
identifier ecu=\PYGZdq{}372304\PYGZdq{} ecuMode=\PYGZdq{}EcuType\PYGZdq{} id=\PYGZdq{}nev9960842n1\PYGZhy{}nev9960865n1\PYGZdq{} read=\PYGZdq{}4\PYGZdq{} type=\PYGZdq{}REID\PYGZdq{} value=\PYGZdq{}5E01\PYGZdq{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{ScriptCarFunction}.png}


\subsection{ScriptType}
\label{\detokenize{vidadatabase/link-carcom-diagswdl:scripttype}}
\sphinxAtStartPar
Checking for our purpose VehCommSpecification:

\sphinxAtStartPar
VehCommSpecification
EcuIdentification
CarStatus
CarConfig
ClearDtc
ReadVin
StatusIdentifier
ReadDtc
ReadDtcEcm
Dro
TransportMode
CustomerParameter
PreProg
EcuReplace
PreCompleteReadout
AlarmMode
KeyPos
DownloadMode
EcuIdentificationHighSpeed
EcuIdentificationLowSpeed
ClockValue
PostReset
PreSwdl


\section{Freeze Frame Param (diagnostic session)}
\label{\detokenize{vidadatabase/freezeframeparam:freeze-frame-param-diagnostic-session}}\label{\detokenize{vidadatabase/freezeframeparam::doc}}
\sphinxAtStartPar
in CARCOM T148 blockmetaPARA is a parameter “showAsFreezeFrame”

\sphinxAtStartPar
the DIAGSWDL database contains data from a diagnostic session.

\sphinxAtStartPar
Vehicle speed refers to blockId, paramId (CARCOM, T141\_Block)


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
id
&\sphinxstyletheadfamily 
\sphinxAtStartPar
fkT142
&\sphinxstyletheadfamily 
\sphinxAtStartPar
fkT143
&\sphinxstyletheadfamily 
\sphinxAtStartPar
name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
fkT190\_Text
&\sphinxstyletheadfamily 
\sphinxAtStartPar
offset
&\sphinxstyletheadfamily 
\sphinxAtStartPar
length
&\sphinxstyletheadfamily 
\sphinxAtStartPar
exclude
&\sphinxstyletheadfamily 
\sphinxAtStartPar
composite
\\
\hline
\sphinxAtStartPar
4760627
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
Vehicle speed
&
\sphinxAtStartPar
24409
&
\sphinxAtStartPar
96
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{itemize}
\item {} 
\sphinxAtStartPar
offset = 96

\item {} 
\sphinxAtStartPar
length = 8

\item {} 
\sphinxAtStartPar
fkT142 = PARAM

\item {} 
\sphinxAtStartPar
fkT143 = “unsigned”

\end{itemize}


\chapter{decoding explained:}
\label{\detokenize{decoding:decoding-explained}}\label{\detokenize{decoding::doc}}
\sphinxAtStartPar
In order to save space, they compressed scripts using zip.

\sphinxAtStartPar
To read the script, you’ll have some work …

\sphinxAtStartPar
so 0x504… is  xml\_data\_compressed\_hex

\sphinxAtStartPar
First we remove the “0x” prefix and convert the remaining hex string to binary data

\sphinxAtStartPar
xml\_data\_bin = bytes.fromhex(xml\_data\_compressed\_hex{[}2:{]})

\sphinxAtStartPar
this data we write to disk as a zip file (and subsequently uncompress it using unzip)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{csv}
\PYG{k+kn}{import} \PYG{n+nn}{subprocess}
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{k}{def} \PYG{n+nf}{sanitize\PYGZus{}filename}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{invalid\PYGZus{}chars} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{char} \PYG{o+ow}{in} \PYG{n}{invalid\PYGZus{}chars}\PYG{p}{:}
        \PYG{n}{filename} \PYG{o}{=} \PYG{n}{filename}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{n}{char}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{filename}

\PYG{c+c1}{\PYGZsh{} Replace \PYGZsq{}your\PYGZus{}input.csv\PYGZsq{} with the actual CSV file name}
\PYG{n}{input\PYGZus{}csv\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{modified\PYGZus{}exportvida.csv}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{input\PYGZus{}csv\PYGZus{}file}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{newline}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{encoding}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{utf\PYGZhy{}8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{csvfile}\PYG{p}{:}
    \PYG{n}{csv\PYGZus{}reader} \PYG{o}{=} \PYG{n}{csv}\PYG{o}{.}\PYG{n}{reader}\PYG{p}{(}\PYG{n}{csvfile}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{csv\PYGZus{}reader}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Extract fields from the CSV row}
        \PYG{n}{fk\PYGZus{}script} \PYG{o}{=} \PYG{n}{row}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{fk\PYGZus{}language} \PYG{o}{=} \PYG{n}{row}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n}{display\PYGZus{}text} \PYG{o}{=} \PYG{n}{row}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
        \PYG{n}{xml\PYGZus{}data\PYGZus{}compressed\PYGZus{}hex} \PYG{o}{=} \PYG{n}{row}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}

        \PYG{c+c1}{\PYGZsh{} Sanitize the display\PYGZus{}text for a filename}
        \PYG{n}{sanitized\PYGZus{}display\PYGZus{}text} \PYG{o}{=} \PYG{n}{sanitize\PYGZus{}filename}\PYG{p}{(}\PYG{n}{display\PYGZus{}text}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Remove the \PYGZdq{}0x\PYGZdq{} prefix and convert the remaining hex string to binary data}
        \PYG{n}{xml\PYGZus{}data\PYGZus{}bin} \PYG{o}{=} \PYG{n+nb}{bytes}\PYG{o}{.}\PYG{n}{fromhex}\PYG{p}{(}\PYG{n}{xml\PYGZus{}data\PYGZus{}compressed\PYGZus{}hex}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Create a sanitized filename with .zip extension and write the binary data to it}
        \PYG{n}{output\PYGZus{}file\PYGZus{}name} \PYG{o}{=} \PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{display\PYGZus{}text}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{row}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{.zip}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{output\PYGZus{}file\PYGZus{}name}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{output\PYGZus{}file}\PYG{p}{:}
            \PYG{n}{output\PYGZus{}file}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{xml\PYGZus{}data\PYGZus{}bin}\PYG{p}{)}

        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Saved binary data for }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{display\PYGZus{}text}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ to }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{output\PYGZus{}file\PYGZus{}name}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\section{volvo model logic}
\label{\detokenize{decoding:volvo-model-logic}}
\sphinxAtStartPar
mdl544yr2005eng167, mdl545yr2005eng167, mdl542yr2006eng167, mdl544yr2006eng167, mdl545yr2006eng167, mdl542yr2007eng167, mdl544yr2007eng167, mdl545yr2007eng167, mdl533yr2007eng167, mdl544yr2008eng167, mdl545yr2008eng167, mdl533yr2008eng167, mdl542yr2008eng167, mdl533yr2008eng199, mdl542yr2008eng199, mdl545yr2008eng199, mdl544yr2008eng199, mdl533yr2009eng199, mdl544yr2009eng199, mdl545yr2009eng199, mdl542yr2009eng199, mdl544yr2010eng199, mdl545yr2010eng199, mdl542yr2010eng199, mdl533yr2010eng199, mdl533yr2011eng199, mdl544yr2011eng199, mdl545yr2011eng199, mdl542yr2011eng199, mdl544yr2012eng199, mdl545yr2012eng199, mdl533yr2012eng199, mdl542yr2012eng199

\sphinxAtStartPar
The decoded XML file contains a description of all the models it applies to.

\sphinxAtStartPar
mdl545yr2008eng167
\begin{itemize}
\item {} 
\sphinxAtStartPar
mdl545 is a volvo estate (multiwagon)

\item {} 
\sphinxAtStartPar
yr2008 is the constructionyear : 2008

\item {} 
\sphinxAtStartPar
eng167 is a 1.6 diesel engine

\end{itemize}

\sphinxAtStartPar
So is it important to select only those XML files in which your model appears.


\section{sniffing in XML files}
\label{\detokenize{decoding:sniffing-in-xml-files}}
\sphinxAtStartPar
unzip Read\_out\_MOST\_nodes\_372302.zip

\sphinxAtStartPar
\sphinxstyleemphasis{372302 is the CEM}

\sphinxAtStartPar
after unzipping we get a file like this one : 0900c8af81d1cb6c

\sphinxAtStartPar
we can have a look:
\sphinxstyleemphasis{xmllint \textendash{}format 0900c8af81d1cb6c | less}
\begin{itemize}
\item {} 
\sphinxAtStartPar
first we need to check if our model mdl545yr2008eng167 is in this file, if not it applies to other models

\end{itemize}


\section{diagnostic extract CEM example}
\label{\detokenize{decoding:diagnostic-extract-cem-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
372302,100,REID,DD06,Strömförsörjningsläge
372302,2,BLOFF,FC,Serviceintervall
372302,4,REID,3F98,ECM start signal
372302,4,REID,5F30,Coolant water temp
372302,100,REID,4007,Workshop test (TPMS) status
372302,100,REID,4125,Batteritemperatur
372302,100,REID,DD02,MECU spänningsmatning
372302,100,REID,DD07,Strömförsörjningsläge
372302,100,REID,DD00,Global tid
372302,100,REID,DD00,Global real time
372302,4,REID,3F02,Clutch pedal sensor
\end{sphinxVerbatim}


\section{reading accelerator pedal position via CAN}
\label{\detokenize{decoding:reading-accelerator-pedal-position-via-can}}
\sphinxAtStartPar
\textless{}identifier ecu=”284101” ecuMode=”EcuType” read=”4” type=”REID” value=”0141”\textgreater{}


\section{Brake light switch}
\label{\detokenize{decoding:brake-light-switch}}
\sphinxAtStartPar
\textless{}identifier ecu=”284101” ecuMode=”EcuType” read=”4” type=”REID” value=”005C”\textgreater{}


\section{Turn indicator}
\label{\detokenize{decoding:turn-indicator}}
\sphinxAtStartPar
641901,4,REID,0005,Turn indicator


\section{Hidden features}
\label{\detokenize{decoding:hidden-features}}
\sphinxAtStartPar
There are numerous scripts, for instance about Vehcom, which could be Vehicle communication ?

\sphinxAtStartPar
\textless{}identifier ecu=”372304” read=”4” type=”REID” value=”9A00”\textgreater{}
\textless{}name=”Interior light, relay” textid=”74202”/\textgreater{}

\sphinxAtStartPar
\sphinxstyleemphasis{this one is for activating the feature?}

\sphinxAtStartPar
\textless{}identifier ecu=”372302” stop=”16” type=”REID” value=”8F31” write=”15”\textgreater{}
\textless{}name=”Rear wash motor relay” textid=”13829”\textgreater{}

\sphinxAtStartPar
\textless{}identifier ecu=”372304” read=”4” type=”REID” value=”8D04”\textgreater{}
\textless{}name=”Brake light, left” textid=”72127”/\textgreater{}

\sphinxAtStartPar
\textless{}identifier ecu=”372304” read=”4” type=”REID” value=”8D05”\textgreater{}
\textless{}name=”Brake light, right” textid=”72128”/\textgreater{}

\sphinxAtStartPar
\textless{}identifier ecu=”372304” read=”4” type=”REID” value=”8D01”\textgreater{}
\textless{}name=”Brake light switch” textid=”4716”/\textgreater{}


\section{CAN diagnostic messages HOWTO}
\label{\detokenize{decoding:can-diagnostic-messages-howto}}

\chapter{Reading the VIN (Vehicle Identification Number)}
\label{\detokenize{vin:reading-the-vin-vehicle-identification-number}}\label{\detokenize{vin::doc}}
\sphinxAtStartPar
VIN stands for Vehicle Identification Number. It is a unique code assigned to every motor vehicle when it’s manufactured. VINs are composed of 17 characters (digits and capital letters) and serve as a vehicle’s fingerprint, providing information about its manufacturer, model, features, and more. VINs are used for various purposes including vehicle registration, tracking recalls, insurance records, and theft prevention.

\sphinxAtStartPar
At the start of the VIDA communication, it does not know your Volvo. (VIDA does not know nothing)


\section{sniffing vida dice}
\label{\detokenize{vin:sniffing-vida-dice}}\begin{itemize}
\item {} 
\sphinxAtStartPar
notice ID = 0x726

\item {} 
\sphinxAtStartPar
DB 0 = 0x03 (meaning 3 bytes of data?)

\item {} 
\sphinxAtStartPar
DB 1 = 0x22

\item {} 
\sphinxAtStartPar
DB 2 = 0xf1 (address 0xF114 as specified in xml)

\item {} 
\sphinxAtStartPar
DB 3 = 0x14

\end{itemize}

\noindent\sphinxincludegraphics{{vin}.png}

\sphinxAtStartPar
The following script I got from the internet, but it shows  that it loads a script ‘Read VIN first readout (Odometer Value) (No immo check)’
\sphinxstyleemphasis{‘Read\_VIN\_first\_readout\_(Odometer\_Value)\_(No\_immo\_check)’:
0900c8af8184c004}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[CarStatus       ][00F][Info]    Init CarStatus
[ScriptProvider  ][00F][Event]   Database: DiagSwdlRepository, SP: GetScript,  Type: \PYGZsq{}ReadVin\PYGZsq{} ScriptId: \PYGZsq{}\PYGZsq{} Language: \PYGZsq{}en\PYGZhy{}US\PYGZsq{} EcuType: \PYGZsq{}\PYGZhy{}1\PYGZsq{} Profile: \PYGZsq{}EMPTYPROFILE,\PYGZsq{}
[ScriptProvider  ][00F][Info]    Fetched script: \PYGZsq{}VCC\PYGZhy{}225200\PYGZhy{}1 1.8\PYGZsq{} title: \PYGZsq{}Read VIN first readout (Odometer Value) (No immo check)\PYGZsq{}
[Script          ][00F][Info]    Running script: \PYGZsq{}VCC\PYGZhy{}225200\PYGZhy{}1 1.8\PYGZsq{} title: \PYGZsq{}Read VIN first readout (Odometer Value) (No immo check)\PYGZsq{}
[CarComRepository][011][Event]   Database: CarCom, SP: general\PYGZus{}GetEcuId, EcuId: 30728270 AA, Result: 821
[DiagnosticVehCom][011][Info]    Using diagnostic part number \PYGZsq{}30728270 AA\PYGZsq{} for system type: \PYGZsq{}0\PYGZsq{}
[CarComRepository][011][Event]   Database: CarCom, SP: vadis\PYGZus{}GetEcuVariantData, EcuVariant: 821
\end{sphinxVerbatim}


\section{Fetched script}
\label{\detokenize{vin:fetched-script}}
\sphinxAtStartPar
The script with title ‘VCC\sphinxhyphen{}225200’ got fetched.
As it happens this script can be found in a VIDA database table.

\sphinxAtStartPar
\sphinxstyleemphasis{fkScript,fkLanguage,DisplayText,XmlDataCompressed,checksum}

\sphinxAtStartPar
‘Read\_VIN\_first\_readout\_(Odometer\_Value)\_(No\_immo\_check)’

\sphinxAtStartPar
uncompressing this : 0900c8af8184c004

\sphinxAtStartPar
which is an XML file


\section{xml content}
\label{\detokenize{vin:xml-content}}
\sphinxAtStartPar
as it happens this part of the script applies to my car
There is a value : 0xF114, sending this to the ECU should get some VIN values.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}node class=\PYGZdq{}Components.ReadVinComponent\PYGZdq{} id=\PYGZdq{}nev9333590\PYGZhy{}nev15368413n1\PYGZdq{} nodeid=\PYGZdq{}EuCD\PYGZdq{} x=\PYGZdq{}620\PYGZdq{} y=\PYGZdq{}275\PYGZdq{}\PYGZgt{}
  \PYGZlt{}property class=\PYGZdq{}Int\PYGZdq{} id=\PYGZdq{}nev9333590\PYGZhy{}nev15368414n1\PYGZdq{} name=\PYGZdq{}CanHiSpeedValue\PYGZdq{} type=\PYGZdq{}In\PYGZdq{} value=\PYGZdq{}500000\PYGZdq{} visible=\PYGZdq{}0\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}property class=\PYGZdq{}Int\PYGZdq{} id=\PYGZdq{}nev9333590\PYGZhy{}nev15368415n1\PYGZdq{} name=\PYGZdq{}UseRelay\PYGZdq{} type=\PYGZdq{}In\PYGZdq{} value=\PYGZdq{}0\PYGZdq{} visible=\PYGZdq{}0\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}property class=\PYGZdq{}Byte\PYGZdq{} id=\PYGZdq{}nev9333590\PYGZhy{}nev15368416n1\PYGZdq{} name=\PYGZdq{}BusId\PYGZdq{} type=\PYGZdq{}In\PYGZdq{} value=\PYGZdq{}1\PYGZdq{} visible=\PYGZdq{}0\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}property class=\PYGZdq{}String\PYGZdq{} id=\PYGZdq{}nev9333590\PYGZhy{}nev15368417n1\PYGZdq{} name=\PYGZdq{}Identifier\PYGZdq{} type=\PYGZdq{}In\PYGZdq{} value=\PYGZdq{}F114\PYGZdq{} visible=\PYGZdq{}0\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}property class=\PYGZdq{}String\PYGZdq{} id=\PYGZdq{}nev9333590\PYGZhy{}nev15368418n1\PYGZdq{} name=\PYGZdq{}Mode\PYGZdq{} type=\PYGZdq{}Internal\PYGZdq{} value=\PYGZdq{}EcuVariant\PYGZdq{} visible=\PYGZdq{}1\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}property class=\PYGZdq{}Int\PYGZdq{} id=\PYGZdq{}nev9333590\PYGZhy{}nev15368419n1\PYGZdq{} name=\PYGZdq{}ServiceId\PYGZdq{} type=\PYGZdq{}In\PYGZdq{} value=\PYGZdq{}100\PYGZdq{} visible=\PYGZdq{}0\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}property class=\PYGZdq{}String\PYGZdq{} id=\PYGZdq{}nev9333590\PYGZhy{}nev15368420n1\PYGZdq{} name=\PYGZdq{}EcuName\PYGZdq{} type=\PYGZdq{}Out\PYGZdq{} value=\PYGZdq{}\PYGZdq{} visible=\PYGZdq{}1\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}property class=\PYGZdq{}Response\PYGZdq{} id=\PYGZdq{}nev9333590\PYGZhy{}nev15368421n1\PYGZdq{} name=\PYGZdq{}Result\PYGZdq{} type=\PYGZdq{}Out\PYGZdq{} value=\PYGZdq{}\PYGZdq{} visible=\PYGZdq{}1\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}property class=\PYGZdq{}String\PYGZdq{} id=\PYGZdq{}nev9333590\PYGZhy{}nev15368422n1\PYGZdq{} name=\PYGZdq{}EcuVariant\PYGZdq{} type=\PYGZdq{}In\PYGZdq{} value=\PYGZdq{}30728270 AA\PYGZdq{} visible=\PYGZdq{}0\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}extension id=\PYGZdq{}nev9333590\PYGZhy{}nev15368423n1\PYGZdq{}/\PYGZgt{}
\PYGZlt{}/node\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now what happens next ?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[CarComRepository][010][Event] Database: CarCom, SP: general\PYGZus{}GetEcuId,
EcuId: 30728270 AA, Result: 821
\end{sphinxVerbatim}

\sphinxAtStartPar
It gets to the CarCom database (just a microsoft sql mdf file\sphinxhyphen{}somewhere at the back of this manual there is a procedure to access these files under linux)

\sphinxAtStartPar
\sphinxstyleemphasis{SP: general\_getEcuID}
\begin{itemize}
\item {} 
\sphinxAtStartPar
SP = stored procedure

\item {} 
\sphinxAtStartPar
Carcom = database

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{select id from T100\_Ecuvariant where identifier = @ecuIdentifier}

\sphinxAtStartPar
so it will get the Ecu variant in the T100 table where EcuId=”30728270 AA”
\begin{itemize}
\item {} 
\sphinxAtStartPar
it comes up with ecuvariant 821

\item {} 
\sphinxAtStartPar
next a stored procedure vadis\_GetEcuVariantData is executed

\end{itemize}

\sphinxAtStartPar
the following is an example of such a stored procedure, it might not be entirely correct, since I used ocr software ..

\begin{sphinxVerbatim}[commandchars=\\\{\}]
SELECT
T100\PYGZus{}EcuVariant. identifier AS DiagNumber,
102\PYGZus{}EcuType.identifier AS EcuTypeldentifier,
T101\PYGZus{}Ecu.identifier AS Eculdentifier,
T121\PYGZus{}Config.commAddress AS EcuAddress,
T100\PYGZus{}EcuVariant.id AS EcuVariantid,
T102\PYGZus{}EcuType.description AS EcuName,
T121\PYGZus{}Config.id As Configid,
T121\PYGZus{}Config.fkt121\PYGZus{}Config\PYGZus{}Gateway As GatewayConfigId,
T122\PYGZus{}Protocol.id AS Protocolld
FROM
T100\PYGZus{}EcuVariant
INNER JOIN
T101\PYGZus{}Ecu ON T100\PYGZus{}EcuVariant.fkT101\PYGZus{}Ecu = T101\PYGZus{}Ecu.id
INNER JOIN
T102\PYGZus{}EcuType ON T101\PYGZus{}Ecu.fkT102\PYGZus{}EcuType
INNER JO1N
T120\PYGZus{}Config\PYGZus{}EcuVariant ON T100\PYGZus{}EcuVariant.id = T120\PYGZus{}Config\PYGZus{}EcuVariant.fkT100\PYGZus{}Ecu
Variant
INNER JOIN
T121\PYGZus{}Config ON T120\PYGZus{}Config\PYGZus{}EcuVariant.fkT121\PYGZus{}Config = T121\PYGZus{}Config.id
INNER JOIN
T122\PYGZus{}Protocol ON T121\PYGZus{}Config.fkT122\PYGZus{}pratocol
WHERE (T100\PYGZus{}EcuVariant.id = @ecuVariantid)
ORDER BY Priority
\end{sphinxVerbatim}


\section{Stored procedure : general\_GetEcuId}
\label{\detokenize{vin:stored-procedure-general-getecuid}}

\chapter{Volvo Diagnostic messages}
\label{\detokenize{volvo-diagnostic:volvo-diagnostic-messages}}\label{\detokenize{volvo-diagnostic::doc}}
\noindent\sphinxincludegraphics{{savvycan}.png}


\section{Sniffing the VIDA diagnostic messages:}
\label{\detokenize{volvo-diagnostic:sniffing-the-vida-diagnostic-messages}}
\sphinxAtStartPar
ID 0x000FFFFE (this is the VIDA tool identifier)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
000FFFFE CD 11 A6 01 96 01 00 00
    |     |  |  |  |    |
    |     |  |  |  |    \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Number of responses expected (query only)
    |     |  |  |  \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Operation ID/Sensor ID (01 96)
    |     |  |  \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Type of operation
    |     |  \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Module id in CEM
    |     \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Message length (always C8 + data byte length)
    \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Start of frame
\end{sphinxVerbatim}


\section{applied to a real message:}
\label{\detokenize{volvo-diagnostic:applied-to-a-real-message}}
\sphinxAtStartPar
(message) CD 50 A6 1A 04 01 00 00

\begin{sphinxVerbatim}[commandchars=\\\{\}]
message length = 0xCD\PYGZhy{}0xC8=5
0x50 module ID CEM
0xA6 Read Current Data By Identifier
0x1A04 372302,4,REID,1A04,Ignition key position
0x1 the number of responses expected

so VIDA is checking key position
\end{sphinxVerbatim}

\sphinxAtStartPar
(message) CD 50 A6 1A 02 01 00 00

\begin{sphinxVerbatim}[commandchars=\\\{\}]
372302,4,REID,1A02,Read 30\PYGZhy{}supply
guess VIDA is checking the voltage of the CEM
\end{sphinxVerbatim}


\section{Guessing the reply}
\label{\detokenize{volvo-diagnostic:guessing-the-reply}}
\sphinxAtStartPar
We are expecting a response on this:
so module 50 has to reply
the ID of replies should be 0x01200021

\sphinxAtStartPar
(message) 01200021 | CE 50 E6 1A 04 0C 0D 00

\sphinxAtStartPar
Our request was an A6, so E6 must mean response by identifier.
The identifier was the key position : 0x1A04

\sphinxAtStartPar
Now remains to guess which values represent the key position ?

\sphinxAtStartPar
I found a clue in the DHA database :
\begin{quote}
\begin{quote}

\sphinxAtStartPar
RESPONSE\_ITEM {[}NAME=IgnitionKeyPos Ignition key not inserted{]}{[}SEND\_ABLE=FALSE{]}{[}NOTE=IgnitionKeyPos{]} {[}NO\_OF\_BYTES=1{]} {[}OFFSET=3{]} {[}MASK={]} {[}UNIT=Ignition key not inserted{]} {[}PRECISION=2{]} {[}SIGNED=U{]} {[}BASE=DEC{]} {[}FORMULA=x\&0b00000111{]} {[}COMP\_VALUE==0b00000000{]} {[}DEP\_RESPITEM=CHECKOK{]} {[}DEP\_RESPITEM\_CHECK=TRUE{]}
RESPONSE\_ITEM {[}NAME=IgnitionKeyPos Pos 0{]}{[}SEND\_ABLE=FALSE{]}{[}NOTE=IgnitionKeyPos{]} {[}NO\_OF\_BYTES=1{]} {[}OFFSET=3{]} {[}MASK={]} {[}UNIT=Pos 0{]} {[}PRECISION=2{]} {[}SIGNED=U{]} {[}BASE=DEC{]} {[}FORMULA=x\&0b00000111{]} {[}COMP\_VALUE==0b00000100{]} {[}DEP\_RESPITEM=CHECKOK{]} {[}DEP\_RESPITEM\_CHECK=TRUE{]}
RESPONSE\_ITEM {[}NAME=IgnitionKeyPos Pos I{]}{[}SEND\_ABLE=FALSE{]}{[}NOTE=IgnitionKeyPos{]} {[}NO\_OF\_BYTES=1{]} {[}OFFSET=3{]} {[}MASK={]} {[}UNIT=Pos I{]} {[}PRECISION=2{]} {[}SIGNED=U{]} {[}BASE=DEC{]} {[}FORMULA=x\&0b00000111{]} {[}COMP\_VALUE==0b00000101{]} {[}DEP\_RESPITEM=CHECKOK{]} {[}DEP\_RESPITEM\_CHECK=TRUE{]}
RESPONSE\_ITEM {[}NAME=IgnitionKeyPos Pos II{]}{[}SEND\_ABLE=FALSE{]}{[}NOTE=IgnitionKeyPos{]} {[}NO\_OF\_BYTES=1{]} {[}OFFSET=3{]} {[}MASK={]} {[}UNIT=Pos II{]} {[}PRECISION=2{]} {[}SIGNED=U{]} {[}BASE=DEC{]} {[}FORMULA=x\&0b00000111{]} {[}COMP\_VALUE==0b00000110{]} {[}DEP\_RESPITEM=CHECKOK{]} {[}DEP\_RESPITEM\_CHECK=TRUE{]}
RESPONSE\_ITEM {[}NAME=IgnitionKeyPos Pos III{]}{[}SEND\_ABLE=FALSE{]}{[}NOTE=IgnitionKeyPos{]} {[}NO\_OF\_BYTES=1{]} {[}OFFSET=3{]} {[}MASK={]} {[}UNIT=Pos III{]} {[}PRECISION=2{]} {[}SIGNED=U{]} {[}BASE=DEC{]} {[}FORMULA=x\&0b00000111{]} {[}COMP\_VALUE==0b00000111{]} {[}DEP\_RESPITEM=CHECKOK{]} {[}DEP\_RESPITEM\_CHECK=TRUE{]}
RESPONSE\_ITEM {[}NAME=IgnitionKeyPosQF {]}{[}SEND\_ABLE=FALSE{]}{[}NOTE=IgnitionKeyPosQF{]} {[}NO\_OF\_BYTES=1{]} {[}OFFSET=3{]} {[}MASK={]} {[}UNIT={]} {[}PRECISION=2{]} {[}SIGNED=U{]} {[}BASE=DEC{]} {[}FORMULA=x\&0b00011000/8{]} {[}COMP\_VALUE={]} {[}DEP\_RESPITEM=CHECKOK{]} {[}DEP\_RESPITEM\_CHECK=TRUE{]}
\end{quote}

\sphinxAtStartPar
END
\end{quote}


\section{Top tip : finding a script}
\label{\detokenize{volvo-diagnostic:top-tip-finding-a-script}}
\sphinxAtStartPar
All the Volvo scripts are under compressed format in an SQL table.
My model is mdl545yr2009.
Suppose I’m interested in the CCM (climate)module: this has the following ID = 871101.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
grep 871101 0900* \PYGZgt{} tempfile \PYGZsh{} this gets me all the scripts for the module
grep mdl545yr2009 tempfile \PYGZgt{} investigatefile \PYGZsh{} this gets me only the scripts for my model
\end{sphinxVerbatim}


\section{Script 0900c8af81d49c30 (EcuIdentification)}
\label{\detokenize{volvo-diagnostic:script-0900c8af81d49c30-ecuidentification}}
\sphinxAtStartPar
in this script all the modules are listed, together with their ID.
Remarkable is this in the XML file :
\textless{}node class=”Components.VehComm” id=”nev10084941n1\sphinxhyphen{}nev12929369n1” nodeid=”ServiceB9F0”  \textgreater{}

\sphinxAtStartPar
This same “B9F0” you can see in the initial communication. (logs)


\section{Using VIDA logs}
\label{\detokenize{volvo-diagnostic:using-vida-logs}}
\sphinxAtStartPar
under VIDA/system/log/Diagnostics each diagnostic sessionlog is saved.
it is filled with readable messages:
\begin{description}
\item[{\textless{}Request EcuAddress=”0B” DiagnosticPartNo=”30670330  A” CompletePartNo=”0008621154  A” Message=”B9F0” OrderPosition=”0”\textgreater{}}] \leavevmode\begin{quote}

\sphinxAtStartPar
\textless{}Response Message=”F9F0000862115420204130670330202041”/\textgreater{}
\end{quote}

\sphinxAtStartPar
\textless{}/Request\textgreater{}

\end{description}

\sphinxAtStartPar
0B corresponds to the ADM module
\begin{quote}
\begin{description}
\item[{\textless{}Request EcuAddress=”50” DiagnosticPartNo=”31254684 AC” CompletePartNo=”0031254903   ” Message=”B9F8” OrderPosition=”13”\textgreater{}}] \leavevmode
\sphinxAtStartPar
\textless{}Response Message=”F9F8000000009287000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF000000000000”/\textgreater{}

\end{description}

\sphinxAtStartPar
\textless{}/Request\textgreater{}
\textless{}Request EcuAddress=”50” DiagnosticPartNo=”31254684 AC” CompletePartNo=”0031254903   ” Message=”B9F5” OrderPosition=”14”\textgreater{}
\begin{quote}

\sphinxAtStartPar
\textless{}Response Message=”F9F5003125467820414300004400003129619720414100004000003129611020414100FE8000”/\textgreater{}
\end{quote}

\sphinxAtStartPar
\textless{}/Request\textgreater{}
\textless{}Request EcuAddress=”50” DiagnosticPartNo=”31254684 AC” CompletePartNo=”0031254903   ” Message=”B9F7” OrderPosition=”15”\textgreater{}
\begin{quote}

\sphinxAtStartPar
\textless{}Response Message=”F9F70030772041202020003125351820204107060504032020420000000000202020FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0030781342204141”/\textgreater{}
\end{quote}

\sphinxAtStartPar
\textless{}/Request\textgreater{}
\end{quote}


\section{Using SQL MDF viewer}
\label{\detokenize{volvo-diagnostic:using-sql-mdf-viewer}}
\sphinxAtStartPar
this tool lets you peek in de MDF (database) files without sqlserver.

\sphinxAtStartPar
not only data but also stored procedures


\chapter{Making sense}
\label{\detokenize{makingsense/index:making-sense}}\label{\detokenize{makingsense/index::doc}}

\section{Reading a partnumber}
\label{\detokenize{makingsense/partnumber:reading-a-partnumber}}\label{\detokenize{makingsense/partnumber::doc}}

\subsection{Reading part number from ECU 0x50}
\label{\detokenize{makingsense/partnumber:reading-part-number-from-ecu-0x50}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} ID=000ffffe data=50 88 00 00 00 00 00 00
\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ID=00000003 data=50 8e 00 00 31 25 49 03
Part Number: 000031254903
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CAN\PYGZus{}HS \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} ID=000ffffe data=cb 50 b9 f0 00 00 00 00
CAN\PYGZus{}HS \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ID=01000003 data=8f 50 f9 f0 00 08 68 85
CAN\PYGZus{}HS \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ID=01000003 data=09 13 20 20 41 30 65 70
CAN\PYGZus{}HS \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ID=01000003 data=4c 24 20 20 41 00 00 00
\end{sphinxVerbatim}

\sphinxAtStartPar
First byte in reply is a technical field, like rolling counter, start (0x80)/end(0x40 flag of the multipart message, etc. The P/N is:

\sphinxAtStartPar
08 68 85 13 == 8688513


\subsection{quick analysis}
\label{\detokenize{makingsense/partnumber:quick-analysis}}
\sphinxAtStartPar
data = cb 50 b9 f0
\begin{itemize}
\item {} 
\sphinxAtStartPar
length = 3 (cb\sphinxhyphen{}c8)

\item {} 
\sphinxAtStartPar
module = 50 (CEM)

\item {} 
\sphinxAtStartPar
type of operation = b9 (read datablock by offset)

\item {} 
\end{itemize}


\subsection{ECU Identification}
\label{\detokenize{makingsense/partnumber:ecu-identification}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
B9F0
  can0  00400003   [8]  8F 50 F9 F0 00 08 69 07
  can0  00400003   [8]  09 19 20 20 20 30 72 89
  can0  00400003   [8]  4C 79 20 41 41 00 00 00

B9F1 \PYGZhy{} B9F4
  can0  00400003   [8]  CC 50 7F B9 12 00 00 00
\end{sphinxVerbatim}


\subsection{Downloadable Software Part Number}
\label{\detokenize{makingsense/partnumber:downloadable-software-part-number}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
B9F5
  can0  00400003   [8]  8F 50 F9 F5 00 30 78 63
  can0  00400003   [8]  09 53 20 41 41 00 00 C0
  can0  00400003   [8]  0A 00 00 30 78 62 13 20
  can0  00400003   [8]  0B 41 41 00 00 40 00 00
  can0  00400003   [8]  0C 30 72 89 81 20 41 41
  can0  00400003   [8]  4C 00 00 70 00 00 00 00
\end{sphinxVerbatim}


\subsection{hex2human}
\label{\detokenize{makingsense/partnumber:hex2human}}
\sphinxAtStartPar
CAN Config Part Number: 0030786353204141 (30786353 AA)
Flash Sector Start Address: 0000C000

\sphinxAtStartPar
Application Software Part Number: 0030786213204141 (30786213 AA)
Flash Sector Start Address: 00004000

\sphinxAtStartPar
Local Config Part Number: 0030728981204141 (30728981 AA)
Flash Sector Start Address: 00007000


\section{Response}
\label{\detokenize{makingsense/respons:response}}\label{\detokenize{makingsense/respons::doc}}
\sphinxAtStartPar
suppose you send a request for information over the canbus, you want to listen for a certain respons as well.

\sphinxAtStartPar
How is this done ?

\sphinxAtStartPar
In the request message, there the “type of operation” is defined :

\sphinxAtStartPar
for example:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A1 No Operation Performed (keep alive)

\item {} 
\sphinxAtStartPar
A3 Security Access Mode

\item {} 
\sphinxAtStartPar
A5 Read Current Data By Offset

\item {} 
\sphinxAtStartPar
A6 Read Current Data By Identifier

\item {} 
\sphinxAtStartPar
A7 Read Current Data By Address

\item {} 
\sphinxAtStartPar
A8 Set Data Transmission

\item {} 
\sphinxAtStartPar
A9 Stop Data Transmission

\end{itemize}

\sphinxAtStartPar
In the vida msql database (T111 service table) these values are defined.
In this table is a field (definition) that describes how this value should “behave”.


\section{example for code B9 (Read Data Block By Offset)}
\label{\detokenize{makingsense/respons:example-for-code-b9-read-data-block-by-offset}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZlt{}request}\PYG{n+nt}{\PYGZgt{}}
\PYG{+w}{    }\PYG{n+nt}{\PYGZlt{}item}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}Service\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{length=}\PYG{l+s}{\PYGZdq{}8\PYGZdq{}}\PYG{+w}{ }\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{    }\PYG{n+nt}{\PYGZlt{}item}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}Identifier\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{length=}\PYG{l+s}{\PYGZdq{}8\PYGZdq{}}\PYG{+w}{ }\PYG{n+nt}{/\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/request\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}response}\PYG{n+nt}{\PYGZgt{}}
\PYG{+w}{    }\PYG{n+nt}{\PYGZlt{}block}\PYG{+w}{ }\PYG{n+na}{id=}\PYG{l+s}{\PYGZdq{}ID2\PYGZus{}1\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{type=}\PYG{l+s}{\PYGZdq{}BLOFF\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{length=}\PYG{l+s}{\PYGZdq{}8\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}Bloff\PYGZdq{}}\PYG{+w}{ }\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{    }\PYG{n+nt}{\PYGZlt{}dynamiclist}\PYG{+w}{ }\PYG{n+na}{type=}\PYG{l+s}{\PYGZdq{}PARAM\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}Parameters\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{blockName=}\PYG{l+s}{\PYGZdq{}Parameter\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{parent=}\PYG{l+s}{\PYGZdq{}ID2\PYGZus{}1\PYGZdq{}}\PYG{+w}{ }\PYG{n+nt}{/\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/response\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This XML snippet describes a structure for a request and a response.

\sphinxAtStartPar
In the request section:
\begin{itemize}
\item {} 
\sphinxAtStartPar
There are three items:
\sphinxhyphen{} “Service” with a length of 8 units.
\sphinxhyphen{} “Identifier” length of 8 units.

\end{itemize}

\sphinxAtStartPar
In the response section:
\sphinxhyphen{} BLOFF (T142 blocktype) this refers to metaTable 146 (is not in database, but guess it is constructed out of XML file data depending on volvo model)
\sphinxhyphen{} ID2\_1 (cannot find any reference in database …)
\sphinxhyphen{} PARAM (T142 blocktype) refers to metaTable 148 (T148\_metaPara) which gives all the parameters for an ECUvariant


\section{VIDA diagnostic logs}
\label{\detokenize{makingsense/respons:vida-diagnostic-logs}}
\sphinxAtStartPar
When using VIDA diagnostic tools, at first it tries to get vehicle data.
As it happens, this might give some insight.

\sphinxAtStartPar
(extract)
\textless{}Request EcuAddress=”0B” DiagnosticPartNo=”30670330 A” CompletePartNo=”0008621154 A” Message=”B9F0” OrderPosition\textgreater{}
\textless{}Response Message=”F9F0000862115420204130670330202041”/\textgreater{}

\sphinxAtStartPar
In the Response Message I can see some of the request

\sphinxAtStartPar
\sphinxstyleemphasis{30670330202041} similar to ”30670330 A”
\sphinxstyleemphasis{0008621154202041} similar to ”0008621154 A”


\section{apply this to real life example}
\label{\detokenize{makingsense/respons:apply-this-to-real-life-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CAN\PYGZus{}HS \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} ID=000ffffe data=cb 50 b9 f0 00 00 00 00
CAN\PYGZus{}HS \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ID=01000003 data=8f 50 f9 f0 00 08 68 85
CAN\PYGZus{}HS \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ID=01000003 data=09 13 20 20 41 30 65 70
CAN\PYGZus{}HS \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ID=01000003 data=4c 24 20 20 41 00 00 00
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
First byte in reply is a technical field (8F)

\item {} 
\sphinxAtStartPar
Second byte is CEM ID (50)

\item {} 
\sphinxAtStartPar
Third (F9) is like reply to B9

\item {} 
\sphinxAtStartPar
Fourth (F0)

\item {} 
\sphinxAtStartPar
Fifth 00

\item {} 
\sphinxAtStartPar
PARTNUMBER  08688513  (08688513  A)

\item {} 
\sphinxAtStartPar
SPACES 20 20

\item {} 
\sphinxAtStartPar
ASCII A

\item {} 
\sphinxAtStartPar
DIAGNOSTICPARTNUMBER  (30657024  A)

\item {} 
\sphinxAtStartPar
SPACES 20 20

\item {} 
\sphinxAtStartPar
ASCII A

\item {} 
\sphinxAtStartPar
PARTNUMBER cannot be found in the database \sphinxstyleemphasis{maybe something like a serialnumber}

\item {} 
\sphinxAtStartPar
in (T100\_ecuvariant) the DIAGNOSTICPARTNUMBER is found and refers to  CEM 372302

\end{itemize}


\section{using the DHA (diagnostic host application) to get a clue}
\label{\detokenize{makingsense/respons:using-the-dha-diagnostic-host-application-to-get-a-clue}}
\sphinxAtStartPar
this was easier to understand, and performs likely the same action

\begin{sphinxVerbatim}[commandchars=\\\{\}]
DIAG\PYGZus{}ITEM [NAME=ECU: HW partnumber and DIA diagnostic number][SEND\PYGZus{}ABLE=TRUE][NOTE=] [FORMAT=OTHER:2] [BASE=HEX] [VALUE=F0] [TYPE=BLOFF][INPUT=FALSE]
BEGIN
  RESPONSE\PYGZus{}ITEM [NAME=ECU Complete Part Number .][SEND\PYGZus{}ABLE=FALSE][NOTE=ECU Complete Part Number] [NO\PYGZus{}OF\PYGZus{}BYTES=8] [OFFSET=2] [MASK=] [UNIT=.] [PRECISION=2] [SIGNED=U] [BASE=5 BCD 3 ASCII] [FORMULA=x] [COMP\PYGZus{}VALUE=] [DEP\PYGZus{}RESPITEM=CHECKOK] [DEP\PYGZus{}RESPITEM\PYGZus{}CHECK=TRUE]
  RESPONSE\PYGZus{}ITEM [NAME=ECU Diagnostic Software number .][SEND\PYGZus{}ABLE=FALSE][NOTE=ECU Diagnostic Software number] [NO\PYGZus{}OF\PYGZus{}BYTES=7] [OFFSET=10] [MASK=] [UNIT=.] [PRECISION=2] [SIGNED=U] [BASE=4 BCD 3 ASCII] [FORMULA=x] [COMP\PYGZus{}VALUE=] [DEP\PYGZus{}RESPITEM=CHECKOK] [DEP\PYGZus{}RESPITEM\PYGZus{}CHECK=TRUE]
END
\end{sphinxVerbatim}

\sphinxAtStartPar
the response is defined :
\begin{itemize}
\item {} 
\sphinxAtStartPar
offset 2 and 8 databytes

\item {} 
\sphinxAtStartPar
offset 10 and 7 databytes

\end{itemize}

\sphinxAtStartPar
according to this the PARTNUMBER would be {\color{red}\bfseries{}*}00*08688513


\section{test\sphinxhyphen{}setup}
\label{\detokenize{makingsense/test-setup:test-setup}}\label{\detokenize{makingsense/test-setup::doc}}
\sphinxAtStartPar
I used a setup on a stm32 to simulate the accelerator pedal.

\sphinxAtStartPar
\sphinxstylestrong{stm32f103c6\sphinxhyphen{}canbus}

\sphinxAtStartPar
This microcontroller sends values to the CANBUS, which can be picked up by the dice software.

\sphinxAtStartPar
In the dice diagnostic software this parameter can be display graphically. (graph)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
frame.id = 0x00222222; //pretend this is the CEM module
frame.extended\PYGZus{}id = true; //volvo uses 29bit
frame.rtr = false;
frame.len = 8;
// Populate the payload bytes with accelerator pedal 0x3F92
frame.data[0] = 0xCE; //length = 5
frame.data[1] = 0x50; //CEM module
frame.data[2] = 0xE6; //reply to A6
frame.data[3] = 0x3F; //accel pedal
frame.data[4] = 0x92; //16bit value
frame.data[5] = 0x24; //value
frame.data[6] = 0x01; //number of messages
frame.data[7] = 0x00;
CAN::transmit(frame);
\end{sphinxVerbatim}


\chapter{Hacking : modifying standard settings}
\label{\detokenize{hacking/index:hacking-modifying-standard-settings}}\label{\detokenize{hacking/index::doc}}
\sphinxAtStartPar
I browsed some forums, and sometimes I would find traces of ECU modders, hackers.
Sometimes this offers some insight into how something actually works.


\section{Checks between the ECM, CEM and BCM}
\label{\detokenize{hacking/checks:checks-between-the-ecm-cem-and-bcm}}\label{\detokenize{hacking/checks::doc}}
\sphinxAtStartPar
The check between the ECM, CEM, and BCM occurs when the ignition key is turned to position II (takes approximately 100 ms). After the CEM has approved the key, the ECM is informed that this is the case.

\sphinxAtStartPar
The following checks occur before the engine is started:


\subsection{Check 1}
\label{\detokenize{hacking/checks:check-1}}
\sphinxAtStartPar
The ECM transmits a request to the BCM to transmit its serial number. The ECM checks that the serial number corresponds to the serial number it has stored. If the serial number is correct, the start conditions have been met.


\subsection{Check 2}
\label{\detokenize{hacking/checks:check-2}}
\sphinxAtStartPar
At the same time as the ECM checks the BCM, the ECM transmits a random number and a code to the CEM. The CEM checks that the code corresponds to the code it has stored. If the code is correct, the CEM transmits another code back to the ECM. The ECM checks the code and compares it to the code it has stored. If it is correct, another start condition has been met.

\sphinxAtStartPar
When Check 1 and Check 2 are complete and approved, the CEM permits the ECM to activate the relays for the starter motor and the engine can be started.

\sphinxAtStartPar
from the manual

\sphinxAtStartPar
Checks between the ECM, CEM and BCM
The check between the ECM, CEM and BCM occurs when the ignition key is turned to position II (takes
approximately 100 ms).
After the CEM has approved the key, the ECM is informed that this is the case.
The following checks occur before the engine is started:
Check 1
The ECM transmits a request to the BCM to transmit its serial number. The ECM checks that the serial
number corresponds to the serial number it has stored. If the serial number is correct the start
conditions have been met.
Check 2
At the same time as the ECM checks the BCM, the ECM transmits a random number and a code to the
CEM. The CEM checks that the code corresponds to the code it has stored. If the code is correct the
CEM transmits another code back to the ECM. The ECM checks the code and compares it to the code
it has stored. If it is correct another start condition has been met.
When Check 1 and Check 2 are complete and approved the CEM permits the ECM to activate the
relays for the starter motor and the engine can be started.


\section{Pincodes}
\label{\detokenize{hacking/pincode:pincodes}}\label{\detokenize{hacking/pincode::doc}}
\sphinxAtStartPar
CEM PIN, ECM PIN, IMMO code, and other codes in Volvo cars: why some units can’t be easily cloned via OBD and can’t be used from another vehicle without modifications.

\sphinxAtStartPar
Every Volvo since 1998 has two basic security levels: CEM and ECM. In newer vehicles, additional units like IEM, VGM, etc., are integrated into this security system.

\sphinxAtStartPar
The content of the programming memory in these units is essentially divided into two parts:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The first programming part of the memory requires a unique PIN code to overwrite the software, dictating how the unit behaves. For example, the software version and configuration table in the CEM unit or, typically from 2008 onwards, the engine maps in the ECM unit.

\item {} 
\sphinxAtStartPar
The second programming part is memory requiring an IMMO PIN, which protects the EEPROM memory where synchronization codes are stored, typically essential for starting the vehicle. It involves synchronizing a unique number between the central CEM unit and the ECM engine unit. If this code does not match, the vehicle will not start. In newer vehicles, additional units like the BCM brake unit, the SCL steering wheel lock, ignition keys, remote controls, and lastly, audio system units that communicate over the MOST optical network, are integrated into the synchronization system.

\end{itemize}

\sphinxAtStartPar
For most vehicles, the CEM/ECM PIN and CEM IMMO can be decoded using VDASH or VDD. This allows most vehicle operations to be performed without the need to remove the unit and physically connect it to a specific programmer. Units that cannot be decoded via OBD can usually be decoded by removing and reading the unit, known as “on the bench.”

\sphinxAtStartPar
Another way to obtain the PIN and IMMO code is to upload software from the official VIDA diagnostic and capture the programming key during the upload. However, Volvo considers this method illegal and in direct violation of the Volvo VIDA licensing agreement.


\subsection{some examples:}
\label{\detokenize{hacking/pincode:some-examples}}\begin{itemize}
\item {} 
\sphinxAtStartPar
CEM PIN \textendash{} for changing vehicle configuration (e.g., activating navigation, changing the US\textgreater{}EU market, removing the speed limiter, etc.), uploading a newer software version
\begin{quote}

\sphinxAtStartPar
decoding via VDASH over OBD \textendash{} P3, SPA 2015\sphinxhyphen{}2018, SPA 2021 if we know the VGM PIN, P2GGD (V8, 3.2i, D5 147kW), P1 GGD (typically 2011+)
decoding via VDD \textendash{} P1, P2 from MY2005+, P3, SPA 2015\sphinxhyphen{}2018, SPA 2021 if we know the VGM PIN
\end{quote}

\item {} 
\sphinxAtStartPar
CEM IMMO \textendash{} adding ignition keys, changing CEM\sphinxhyphen{}ECM synchronization codes, pairing a new SCL or SCU, pairing audio system components
\begin{quote}

\sphinxAtStartPar
decoding via VDASH P2 except for V8, 3.2i, D5 147kW, P3 except for V40/V40CC
\end{quote}

\item {} 
\sphinxAtStartPar
ECM PIN \textendash{} performance optimization, EGR / DPF removal, deactivation of error codes
\begin{quote}

\sphinxAtStartPar
not needed for P2, not needed for P1 until approximately MY2011
decoding via OBD at P3 DENSO units, SPA 2015\sphinxhyphen{}2018 using UCBP
cannot be decoded at P3 5\sphinxhyphen{}cylinder diesel engines
\end{quote}

\item {} 
\sphinxAtStartPar
ECM IMMO \textendash{} changing the CEM\sphinxhyphen{}ECM synchronization key, pairing the BCM unit
\begin{quote}

\sphinxAtStartPar
decoding via VDASH P1 1.6D 80kW and D5 and 2.4D 5\sphinxhyphen{}cylinder, P2 except for V8, 3.2i, D5 147kW, DENSO VEA P3 and SPA 2014 \textendash{} 2018
\end{quote}

\item {} 
\sphinxAtStartPar
VGM PIN \textendash{} only in vehicles with the iCUP (Android) system for erasing diagnostic codes throughout the vehicle and for any other vehicle operations
\begin{quote}

\sphinxAtStartPar
Cannot be decoded via OBD, must be obtained from the official Volvo VIDA diagnostics
\end{quote}

\end{itemize}


\section{Bootloaders}
\label{\detokenize{hacking/bootloaders:bootloaders}}\label{\detokenize{hacking/bootloaders::doc}}
\noindent\sphinxincludegraphics{{bootloader}.png}

\sphinxAtStartPar
When initializing, the ECU first initiates the boot loader. The boot loader comprises two distinct parts: a primary boot loader (PBL) and a secondary boot loader (SBL). In its default mode, the PBL loads the application software stored in the flash memory. Due to specific constraints such as a small memory size (16k) and the inability to be modified post\sphinxhyphen{}production, the PBL is unsuitable for programming or updating data in the flash memory. For these tasks, the SBL is utilized. The SBL is transferred by the primary loader into RAM and subsequently activated. It then assumes responsibility for managing the flash memory, including tasks such as erasing or reprogramming, and the software download process.


\section{The software download process}
\label{\detokenize{hacking/bootloaders:the-software-download-process}}
\sphinxAtStartPar
To download data, the ECU should be put in programming mode. First the SBL is
downloaded into RAM by means of PBL. After SBL is activated, clear the flash memory. The next step is the download of
data files. Finally the ECU is reset to erase RAM and put back in default mode.


\section{Keys}
\label{\detokenize{hacking/keys:keys}}\label{\detokenize{hacking/keys::doc}}
\sphinxAtStartPar
CEM EEPROM:

\sphinxAtStartPar
From the xx256 MCU eeprom. I found based on some other forum posts where the keys are stored (transponder portion at least). They are each 4 bytes and there are a maximum of 6 keys that can be added to the car.

\sphinxAtStartPar
YV1MS682442020566 MCU2 EEPROM (4K)

\sphinxAtStartPar
I do not know if there are any checksums on this.

\sphinxAtStartPar
Above you can see that the vehicle has 4 transponders/keys added, with two sets of 4 bytes blank for slots 5 and 6.  On the ICM display, if I go into the information section it also reports there are 4 keys.

\sphinxAtStartPar
The keys I believe are ID48 Megamos transponders.


\subsection{Key Fob:}
\label{\detokenize{hacking/keys:key-fob}}
\sphinxAtStartPar
There is the active component that I believe transmits at 315MHz when you push the buttons. This is picked up by a receiver on top of the DIM (Cluster). The passive part is in the plastic housing, a small glass RFID transponder that when inserted into the ignition is verified.

\noindent\sphinxincludegraphics{{key1}.png}

\noindent\sphinxincludegraphics{{key2}.png}


\subsection{Ignition Transponder Reader:}
\label{\detokenize{hacking/keys:ignition-transponder-reader}}
\sphinxAtStartPar
This is a 3 wire device, 12V, GND and LIN. The LIN bus is shared with the SCL (Steering Column Lock) module, which are both connected to the CEM.

\noindent\sphinxincludegraphics{{key3}.png}


\chapter{DBC (Database Container) Files: The Key to Decoding CAN Bus Messages}
\label{\detokenize{dbc:dbc-database-container-files-the-key-to-decoding-can-bus-messages}}\label{\detokenize{dbc::doc}}
\sphinxAtStartPar
\sphinxurl{https://www.csselectronics.com/pages/dbc-editor-can-bus-database}


\section{example : VehicleSpeed}
\label{\detokenize{dbc:example-vehiclespeed}}
\sphinxAtStartPar
Vehiclespeed for a Volvo C30 has CAN ID 2104136, but this if followed by the speed data. In a dbc file is defined how this speed can be decoded from CAN messages.
{\color{red}\bfseries{}BO\_} 2182103350 VehicleSpeedBCM: 8 BCM
\begin{quote}

\sphinxAtStartPar
{\color{red}\bfseries{}SG\_} VehicleSpeed : \sphinxhref{mailto:55|16@0+}{55|16@0+} (0.01,0) {[}0|65535{]} ” km/h” XXX
\end{quote}


\section{short intro}
\label{\detokenize{dbc:short-intro}}
\sphinxAtStartPar
In the world of automotive communication systems, Controller Area Network (CAN) bus plays a crucial role in facilitating communication between various electronic control units (ECUs) within vehicles. Understanding and decoding CAN bus messages is essential for tasks such as vehicle diagnostics, monitoring, and control.

\sphinxAtStartPar
DBC (Database Container) files serve as the cornerstone for decoding CAN bus messages. Developed by Vector Informatik, DBC files are structured databases that define the parameters, signals, and message formats used in CAN bus networks. These files provide a standardized format for describing the communication protocols and message data within a CAN network.

\sphinxAtStartPar
Within a DBC file, each message is defined with its identifier, data length, and the signals contained within it. Signals represent specific data parameters transmitted within CAN messages, such as vehicle speed, engine RPM, or sensor readings. Each signal is associated with attributes such as scaling factors, offsets, and units, which are crucial for interpreting the raw data received from the CAN bus.

\sphinxAtStartPar
DBC files also include information about the physical layout of the data within CAN messages, such as the byte order (big\sphinxhyphen{}endian or little\sphinxhyphen{}endian) and the bit arrangement of individual signals. This information is essential for correctly parsing and decoding the data received from the CAN bus.

\sphinxAtStartPar
In practical applications, DBC files are used in conjunction with software tools known as CAN bus analyzers or decoders. These tools parse incoming CAN bus data using the information provided in the DBC file, allowing users to interpret and visualize the data in a human\sphinxhyphen{}readable format. This enables engineers, developers, and technicians to monitor vehicle performance, diagnose faults, and develop new automotive functionalities with ease.

\sphinxAtStartPar
In summary, DBC files serve as invaluable resources for decoding CAN bus messages, providing a standardized and structured approach to understanding the communication protocols used in automotive networks. With DBC files and the appropriate decoding tools, unlocking the wealth of data flowing through the CAN bus becomes accessible, empowering automotive professionals to innovate and optimize vehicle systems effectively.


\chapter{Openmoose}
\label{\detokenize{openmoose:openmoose}}\label{\detokenize{openmoose::doc}}
\sphinxAtStartPar
Since I have a Dice cable (usb to OBD2), I wondered if this is usable to send/receive custom messages. Openmoose is a project to re\sphinxhyphen{}write the ECU using the dice cable, so figured it should be usable for diagnostic purposes.

\sphinxAtStartPar
\sphinxurl{http://www.openmoose.net/}

\sphinxAtStartPar
\sphinxurl{https://github.com/rlinewiz/OpenMoose}

\sphinxAtStartPar
Read and write your Volvo ECU (Bosch ME7) using a DiCE cable.


\section{modding}
\label{\detokenize{openmoose:modding}}
\sphinxAtStartPar
jetbrains dotPeek was used to have a look at the J2534.dll.

\sphinxAtStartPar
I used a vbox which contained all the microsoft development, but it crashed often (my fault?).

\sphinxAtStartPar
\sphinxurl{https://developer.microsoft.com/en-us/windows/downloads/virtual-machines/}


\section{code}
\label{\detokenize{openmoose:code}}
\sphinxAtStartPar
The following code was found in the J2534.dll, and shows how a can data\sphinxhyphen{}message is composed. This can be used to send custom messages.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   public static readonly CANPacket msgCANReadECMConfig = new CANPacket(new byte[8]
\PYGZob{}
  (byte) 203,
  (byte) 122,
  (byte) 185,
  (byte) 245,
  (byte) 0,
  (byte) 0,
  (byte) 0,
  (byte) 0
\PYGZcb{});
\end{sphinxVerbatim}

\sphinxAtStartPar
The extended ID, if not provided is a standard diagnostic EID like 0xFFFFFE.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
public CANPacket(byte[] data)
\PYGZob{}
  this.data = new byte[data.Length + 4];
  this.data[0] = (byte) 0;
  this.data[1] = (byte) 15;
  this.data[2] = byte.MaxValue;
  this.data[3] = (byte) 254;
  for (int index = 0; index \PYGZlt{} data.Length; ++index)
    this.data[index + 4] = data[index];
  this.protocolType = PROTOCOL\PYGZus{}TYPE.CAN\PYGZus{}XON\PYGZus{}XOFF;
\PYGZcb{}
\end{sphinxVerbatim}

\sphinxAtStartPar
The EID can be given as a parameter as well.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
public CANPacket(byte[] data, int eid)
\PYGZob{}
  byte[] eid1 = new byte[4]
  \PYGZob{}
    (byte) 0,
    (byte) 0,
    (byte) 0,
    (byte) eid
  \PYGZcb{};
  eid1[2] = (byte) (eid \PYGZgt{}\PYGZgt{} 8);
  eid1[1] = (byte) (eid \PYGZgt{}\PYGZgt{} 16);
  eid1[0] = (byte) (eid \PYGZgt{}\PYGZgt{} 24);
  this.setupCANPacketEID(data, eid1);
\PYGZcb{}
\end{sphinxVerbatim}


\chapter{using    candump}
\label{\detokenize{candump:using-candump}}\label{\detokenize{candump::doc}}
\sphinxAtStartPar
on linux, first load the modules, then start the deamon with 500K baud (\sphinxhyphen{}s6)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
modprobe can
modprobe can\PYGZhy{}raw
modprobe slcan
slcand \PYGZhy{}s6 \PYGZhy{}S2000000 /dev/ttyACM1 can0
ifconfig can0 up
\end{sphinxVerbatim}


\section{using DICE cable and modding OpenMoose}
\label{\detokenize{candump:using-dice-cable-and-modding-openmoose}}
\sphinxAtStartPar
after modifying OpenMoose, I get to see my custom\sphinxhyphen{}message (22,23,24,25,26,27,28)
which proves that the DICE cable can be used!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@naj\PYGZhy{}Latitude\PYGZhy{}5520:\PYGZti{}\PYGZsh{} candump can0 \PYGZhy{}ta
 (1710516027.391935)  can0  000FFFFE   [8]  D8 00 00 00 00 00 00 00
 (1710516028.391723)  can0  000FFFFE   [8]  D8 00 00 00 00 00 00 00
 (1710516028.594302)  can0  000FFFFE   [8]  16 17 18 19 1A 1B 1C 1D
 (1710516029.391926)  can0  000FFFFE   [8]  D8 00 00 00 00 00 00 00
\end{sphinxVerbatim}


\chapter{baud \& bit}
\label{\detokenize{apb:baud-bit}}\label{\detokenize{apb::doc}}
\noindent\sphinxincludegraphics{{canbitsbauds}.png}

\sphinxAtStartPar
In the context of STM32 microcontrollers, the APB (Advanced Peripheral Bus) clock is one of the buses used for connecting peripherals, and it’s typically derived from the system clock (HCLK). The time period of the APB clock refers to the duration of one clock cycle on this bus. It is the reciprocal of the frequency.

\sphinxAtStartPar
The formula to calculate the time period (T) is:

\sphinxAtStartPar
{[} T = frac\{1\}\{text\{APB clock frequency\}\} {]}

\sphinxAtStartPar
Where:
\begin{itemize}
\item {} 
\sphinxAtStartPar
( T ) is the time period.

\item {} 
\sphinxAtStartPar
(text\{APB clock frequency\}) is the frequency of the APB clock.

\end{itemize}

\sphinxAtStartPar
So, if you have the frequency of the APB clock, you can calculate the time it takes for one clock cycle.

\sphinxAtStartPar
For example, if the APB clock operates at 36 MHz, the time period (( T )) would be:

\sphinxAtStartPar
{[} T = frac\{1\}\{36 , text\{MHz\}\} approx 27.78 , text\{ns\} {]}

\sphinxAtStartPar
Understanding the time period of the APB clock is important when configuring peripherals that depend on timing, such as setting up the baud rate for communication peripherals like USART, SPI, or CAN. These peripherals often have timing parameters specified in terms of clock cycles or time intervals, so knowing the time period allows you to set these parameters accurately.


\chapter{STM microcontrollers used with CAN}
\label{\detokenize{stm/index:stm-microcontrollers-used-with-can}}\label{\detokenize{stm/index::doc}}
\sphinxAtStartPar
Since I was inspired by the openinverter project to acquire some new skills (\sphinxurl{https://openinverter.org/wiki/Main\_Page}), I went trough my drawer to scramble all the STM hardware together, since that is what they use. The programming is done using libopencm3.

\sphinxAtStartPar
Eventually I bought some cheap stm32 boards which were low spec, but still usefull for CAN communication.


\section{stm32f103}
\label{\detokenize{stm/stm32f103:stm32f103}}\label{\detokenize{stm/stm32f103::doc}}
\noindent\sphinxincludegraphics{{board}.png}

\noindent\sphinxincludegraphics{{board-usage}.png}

\noindent\sphinxincludegraphics{{pulseview}.png}

\noindent\sphinxincludegraphics{{pulseview-can}.png}


\subsection{Bluepill}
\label{\detokenize{stm/stm32f103:bluepill}}
\noindent\sphinxincludegraphics{{bluepill}.png}


\section{stm32f103}
\label{\detokenize{stm/stm32f429i:stm32f103}}\label{\detokenize{stm/stm32f429i::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{MX\PYGZus{}CAN2\PYGZus{}Init}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PB6}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{TX}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{en}\PYG{+w}{ }\PYG{n}{PB12}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{RX}\PYG{p}{)}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{HAL\PYGZus{}CAN\PYGZus{}MspInit}\PYG{p}{(}\PYG{n}{CAN\PYGZus{}HandleTypeDef}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{hcan}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{GPIO\PYGZus{}InitTypeDef}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}InitStruct}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{if}\PYG{p}{(}\PYG{n}{hcan}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Instance}\PYG{o}{=}\PYG{o}{=}\PYG{n}{CAN2}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{c+cm}{/* USER CODE BEGIN CAN2\PYGZus{}MspInit 0 */}

\PYG{+w}{  }\PYG{c+cm}{/* USER CODE END CAN2\PYGZus{}MspInit 0 */}
\PYG{+w}{    }\PYG{c+cm}{/* Peripheral clock enable */}
\PYG{+w}{    }\PYG{n}{\PYGZus{}\PYGZus{}HAL\PYGZus{}RCC\PYGZus{}CAN2\PYGZus{}CLK\PYGZus{}ENABLE}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{\PYGZus{}\PYGZus{}HAL\PYGZus{}RCC\PYGZus{}CAN1\PYGZus{}CLK\PYGZus{}ENABLE}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{\PYGZus{}\PYGZus{}HAL\PYGZus{}RCC\PYGZus{}GPIOB\PYGZus{}CLK\PYGZus{}ENABLE}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+cm}{/**CAN2 GPIO Configuration}
\PYG{c+cm}{    PB12     \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} CAN2\PYGZus{}RX}
\PYG{c+cm}{    PB6     \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} CAN2\PYGZus{}TX}
\PYG{c+cm}{    */}
\PYG{+w}{    }\PYG{n}{GPIO\PYGZus{}InitStruct}\PYG{p}{.}\PYG{n}{Pin}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}12}\PYG{o}{|}\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}6}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{GPIO\PYGZus{}InitStruct}\PYG{p}{.}\PYG{n}{Mode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}MODE\PYGZus{}AF\PYGZus{}PP}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{GPIO\PYGZus{}InitStruct}\PYG{p}{.}\PYG{n}{Pull}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}NOPULL}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{GPIO\PYGZus{}InitStruct}\PYG{p}{.}\PYG{n}{Speed}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}SPEED\PYGZus{}FREQ\PYGZus{}VERY\PYGZus{}HIGH}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{GPIO\PYGZus{}InitStruct}\PYG{p}{.}\PYG{n}{Alternate}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}AF9\PYGZus{}CAN2}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}Init}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{GPIO\PYGZus{}InitStruct}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+cm}{/* USER CODE BEGIN CAN2\PYGZus{}MspInit 1 */}

\PYG{+w}{  }\PYG{c+cm}{/* USER CODE END CAN2\PYGZus{}MspInit 1 */}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{board overview}
\label{\detokenize{stm/stm32f429i:board-overview}}
\noindent\sphinxincludegraphics{{stm32f429i-board-CAN2}.png}


\subsection{pinheader left}
\label{\detokenize{stm/stm32f429i:pinheader-left}}
\noindent\sphinxincludegraphics{{stm32f429i-left}.png}


\subsection{pinheader right}
\label{\detokenize{stm/stm32f429i:pinheader-right}}
\noindent\sphinxincludegraphics{{stm32f429i-right}.png}


\section{using a serial port}
\label{\detokenize{stm/serial:using-a-serial-port}}\label{\detokenize{stm/serial::doc}}
\sphinxAtStartPar
Due to non working usb\sphinxhyphen{}uart plugs, I used what I had : an orange pi pc, running armbian. This allowed me to configure 3 serial ports.

\sphinxAtStartPar
Later on in my project I configured a stm32f103c6 to be used as an uart bridge.


\subsection{using the GPIO header of an orange pi}
\label{\detokenize{stm/serial:using-the-gpio-header-of-an-orange-pi}}
\noindent\sphinxincludegraphics{{orangepi2E-serialport}.png}

\sphinxAtStartPar
I use armbian on a orange pi.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo\PYG{+w}{ }armbian\PYGZhy{}config
\end{sphinxVerbatim}

\sphinxAtStartPar
In the Armbian configuration utility, navigate to \sphinxstyleemphasis{System \textgreater{} Hardware} and select the appropriate option to apply device tree overlays.


\chapter{What is a SocketCAN Interface?}
\label{\detokenize{socketcan:what-is-a-socketcan-interface}}\label{\detokenize{socketcan::doc}}
\sphinxAtStartPar
SocketCAN is a set of open\sphinxhyphen{}source CAN drivers and a networking stack contributed by Volkswagen Research to the Linux kernel. CAN (Controller Area Network) is a standard communication protocol used in embedded systems such as automotive and industrial applications for message\sphinxhyphen{}based communication between microcontrollers and other devices.

\sphinxAtStartPar
SocketCAN provides a standardized API (Application Programming Interface) for CAN communication in the Linux environment. It allows applications to communicate with CAN devices using a set of socket\sphinxhyphen{}based interfaces similar to those used for networking. This abstraction makes it easier for developers to work with CAN devices, as they can use familiar socket programming techniques.

\sphinxAtStartPar
Key features of SocketCAN include:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Standardized API}: SocketCAN provides a consistent API for CAN communication, making it easier for developers to write applications that work with different CAN devices.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Socket\sphinxhyphen{}based Interface}: Applications interact with CAN devices using sockets, which allows for easy integration into existing network programming paradigms.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Support for Multiple CAN Devices}: SocketCAN supports multiple CAN devices simultaneously, allowing for complex CAN networks to be easily managed.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Integration with Linux Kernel}: SocketCAN is integrated into the Linux kernel, making it readily available on Linux\sphinxhyphen{}based systems without the need for additional drivers.

\end{enumerate}

\sphinxAtStartPar
Overall, SocketCAN simplifies the development of applications that need to communicate over CAN networks on Linux systems, providing a standardized and efficient interface for CAN communication.


\section{Configuring SocketCAN interface : stm32multiserial}
\label{\detokenize{socketcan:configuring-socketcan-interface-stm32multiserial}}
\sphinxAtStartPar
STM32F103 Bluepill devices are known for their affordability and versatility. These microcontroller units (MCUs) can be easily configured to function as a virtual COM port, making them popular choices for various embedded systems and DIY projects.

\sphinxAtStartPar
However, a peculiar design flaw limits the simultaneous use of the CAN (Controller Area Network) port and the Virtual COM port on these devices. This limitation poses a challenge for applications requiring both functionalities concurrently.

\sphinxAtStartPar
To circumvent this limitation, I adopted a workaround solution: utilizing two STM32 devices instead of one. By dedicating one device to forward data to the serial port and another to forward this data to the virtual COM port, I effectively bypassed the restriction. Fortunately, the low cost of these Bluepill devices made this workaround feasible, despite the need for additional hardware.

\sphinxAtStartPar
Although unconventional, this approach proved effective in achieving the desired functionality without compromising on cost\sphinxhyphen{}effectiveness. It underscores the adaptability and flexibility of STM32F103 Bluepill devices in addressing real\sphinxhyphen{}world constraints and challenges in embedded systems development.

\sphinxAtStartPar
\sphinxstylestrong{The serial ports of the Orange Pi PC seemed limited to 115200 baud. When sampling 500k baud CAN traffic, this becomes a problem. The STM32 devices allow for higher baudrates. I modified the original STM32MultiSerial UART2 port to allow for higher baudrates.}

\sphinxAtStartPar
on github is this stm32multiserial repository, which is also suited for the stm32f103c6 so stm32f103xx.

\sphinxAtStartPar
\sphinxhref{https://github.com/unkier/stm32multiserial}{STM32MultiSerial GitHub Repository}

\sphinxAtStartPar
if all goes well this device will show up as  (dmesg)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}\PYG{+w}{ }\PYG{l+m}{6497}.544752\PYG{o}{]}\PYG{+w}{ }usb\PYG{+w}{ }\PYG{l+m}{3}\PYGZhy{}2:\PYG{+w}{ }Product:\PYG{+w}{ }STM32\PYG{+w}{ }Virtual\PYG{+w}{ }ComPort
\PYG{o}{[}\PYG{+w}{ }\PYG{l+m}{6497}.544756\PYG{o}{]}\PYG{+w}{ }usb\PYG{+w}{ }\PYG{l+m}{3}\PYGZhy{}2:\PYG{+w}{ }Manufacturer:\PYG{+w}{ }STMicroelectronics
\PYG{o}{[}\PYG{+w}{ }\PYG{l+m}{6497}.544759\PYG{o}{]}\PYG{+w}{ }usb\PYG{+w}{ }\PYG{l+m}{3}\PYGZhy{}2:\PYG{+w}{ }SerialNumber:\PYG{+w}{ }00000000001A
\PYG{o}{[}\PYG{+w}{ }\PYG{l+m}{6497}.550462\PYG{o}{]}\PYG{+w}{ }cdc\PYGZus{}acm\PYG{+w}{ }\PYG{l+m}{3}\PYGZhy{}2:1.0:\PYG{+w}{ }ttyACM0:\PYG{+w}{ }USB\PYG{+w}{ }ACM\PYG{+w}{ }device
\PYG{o}{[}\PYG{+w}{ }\PYG{l+m}{6497}.551289\PYG{o}{]}\PYG{+w}{ }cdc\PYGZus{}acm\PYG{+w}{ }\PYG{l+m}{3}\PYGZhy{}2:1.2:\PYG{+w}{ }ttyACM1:\PYG{+w}{ }USB\PYG{+w}{ }ACM\PYG{+w}{ }device
\end{sphinxVerbatim}

\sphinxAtStartPar
in this case /dev/ttyACM0 and /dev/ttyACM1 will be usable as virtual com port

\sphinxAtStartPar
this works together with the serial can :

\sphinxAtStartPar
\sphinxhref{https://github.com/walmis/stm32-slcan}{STM32\sphinxhyphen{}SLCAN}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo\PYG{+w}{ }modprobe\PYG{+w}{ }can
sudo\PYG{+w}{ }modprobe\PYG{+w}{ }can\PYGZhy{}raw
sudo\PYG{+w}{ }modprobe\PYG{+w}{ }slcan
sudo\PYG{+w}{ }slcand\PYG{+w}{ }\PYGZhy{}s5\PYG{+w}{ }\PYGZhy{}S2000000\PYG{+w}{ }/dev/ttyUSB0\PYG{+w}{ }can0\PYG{+w}{ }\PYG{c+c1}{\PYGZsh{} CAN Speed 5 \PYGZhy{}\PYGZgt{}250 kBaud, 2,000,000 Baud serial}
\PYG{o}{(}or\PYG{o}{)}
su\PYG{+w}{ }slcand\PYG{+w}{ }\PYGZhy{}s4\PYG{+w}{ }\PYGZhy{}S2000000\PYG{+w}{ }/dev/ttyACM1\PYG{+w}{ }can0\PYG{+w}{ }\PYG{c+c1}{\PYGZsh{}125kBaud CAN and stm32multiserial device}
ifconfig\PYG{+w}{ }can0\PYG{+w}{ }up
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{the \sphinxhyphen{}S2000000 is the serial baudrate, which is very high, standard usb\sphinxhyphen{}uart devices might not be able to cope}

\noindent\sphinxincludegraphics{{3xstm32_bb}.png}


\chapter{Linux at home}
\label{\detokenize{linux/index:linux-at-home}}\label{\detokenize{linux/index::doc}}
\sphinxAtStartPar
I prefer linux to windows, but a lot of software in the CAN space is windows.
I resolved this partly by using a virtualbox, porting the VIDA database to linux.
My cheap logic analyzer proved very useful in analyzing CAN traffic.


\section{Using mssql database on linux}
\label{\detokenize{linux/rebuild-database:using-mssql-database-on-linux}}\label{\detokenize{linux/rebuild-database::doc}}
\sphinxAtStartPar
Turns out it is possible to use ms\sphinxhyphen{}sqlserver under linux

\sphinxAtStartPar
\sphinxurl{https://learn.microsoft.com/en-us/sql/linux/quickstart-install-connect-ubuntu?view=sql-server-ver16\&tabs=ubuntu2004}

\sphinxAtStartPar
controlling the beast ….

\begin{sphinxVerbatim}[commandchars=\\\{\}]
systemctl status mssql\PYGZhy{}server
systemctl stop mssql\PYGZhy{}server
systemctl disable mssql\PYGZhy{}server
systemctl enable mssql\PYGZhy{}server
\end{sphinxVerbatim}

\sphinxAtStartPar
A nice GUI would be cool!!

\sphinxAtStartPar
\sphinxurl{https://dbeaver.io}
sudo add\sphinxhyphen{}apt\sphinxhyphen{}repository ppa:serge\sphinxhyphen{}rider/dbeaver\sphinxhyphen{}ce
sudo apt\sphinxhyphen{}get update
sudo apt\sphinxhyphen{}get install dbeaver\sphinxhyphen{}ce

\sphinxAtStartPar
And now .. a way to get Volvo vida files accessible under linux.
This allows for exporting data and having access to stored procedures. (the tools on windows seemed rather limiting…)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
/opt/mssql\PYGZhy{}tools/bin/sqlcmd \PYGZhy{}S . \PYGZhy{}U sa \PYGZhy{}P GunnarS3g3 \PYGZhy{}Q \PYGZdq{}CREATE DATABASE BaseData\PYGZus{}Data ON (FILENAME = \PYGZsq{}/var/opt/mssql/data/BaseData\PYGZus{}Data.MDF\PYGZsq{}),(FILENAME = \PYGZsq{}/var/opt/mssql/data/BaseData\PYGZus{}Data\PYGZus{}log.ldf\PYGZsq{} ) FOR ATTACH\PYGZus{}REBUILD\PYGZus{}LOG\PYGZdq{}

/opt/mssql\PYGZhy{}tools/bin/sqlcmd \PYGZhy{}S . \PYGZhy{}U sa \PYGZhy{}P GunnarS3g3 \PYGZhy{}Q \PYGZdq{}CREATE DATABASE CARCOM ON (FILENAME = \PYGZsq{}/twee/volvo/CarComRT\PYGZus{}Data.MDF\PYGZsq{}),(FILENAME = \PYGZsq{}/twee/volvo/CarcomRT\PYGZus{}Log.LDF\PYGZsq{} ) FOR ATTACH\PYGZus{}REBUILD\PYGZus{}LOG\PYGZdq{}

/opt/mssql\PYGZhy{}tools/bin/sqlcmd \PYGZhy{}S . \PYGZhy{}U sa \PYGZhy{}P GunnarS3g3 \PYGZhy{}Q \PYGZdq{}CREATE DATABASE DIAGSWDLREPOSITORY ON (FILENAME = \PYGZsq{}/twee/volvo/DiagSwdlRepository\PYGZus{}Data.MDF\PYGZsq{}),(FILENAME = \PYGZsq{}/twee/volvo/DiagSwdlRepository\PYGZus{}log.LDF \PYGZsq{} ) FOR ATTACH\PYGZdq{}

/opt/mssql\PYGZhy{}tools/bin/sqlcmd \PYGZhy{}S . \PYGZhy{}U sa \PYGZhy{}P GunnarS3g3 \PYGZhy{}Q \PYGZdq{}CREATE DATABASE DIAGSWDLSESSION ON (FILENAME = \PYGZsq{}/twee/volvo/DiagSwdlSession\PYGZus{}Data.MDF\PYGZsq{}),(FILENAME = \PYGZsq{}/twee/volvo/DiagSwdlSession\PYGZus{}log.LDF\PYGZsq{} ) FOR ATTACH\PYGZdq{}
\end{sphinxVerbatim}

\sphinxAtStartPar
In Dbeaver the stored procedure can be executed, by right clicking.
It then opens a new windows, where you can add the parameter.

\sphinxAtStartPar
To execute a stored procedure in SQL Server that requires a parameter, you can use the EXEC statement followed by the name of the stored procedure and provide the parameter value within parentheses. Here’s how you can pass a parameter to the stored procedure {[}dbo{]}.{[}vadis\_GetEcuVariantData{]}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
USE [CARCOM]
DECLARE @return\PYGZus{}value int
DECLARE @parameter\PYGZus{}name int = 821
EXEC @return\PYGZus{}value = [dbo].[vadis\PYGZus{}GetEcuVariantData]@parameter\PYGZus{}name

SELECT       \PYGZsq{}Return Value\PYGZsq{} = @return\PYGZus{}value
\end{sphinxVerbatim}

\sphinxAtStartPar
it return DiagNumber : 30728270 AA


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
DiagNumber
&\sphinxstyletheadfamily 
\sphinxAtStartPar
EcuTypeI
&\sphinxstyletheadfamily 
\sphinxAtStartPar
EcuI
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Add
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Ecu
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Nam
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CfgId
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Gwy
&\sphinxstyletheadfamily 
\sphinxAtStartPar
ProtocolId
\\
\hline
\sphinxAtStartPar
30728270 AA
&
\sphinxAtStartPar
372,302
&
\sphinxAtStartPar
CEM
&
\sphinxAtStartPar
52
&
\sphinxAtStartPar
821
&
\sphinxAtStartPar
CEM
&
\sphinxAtStartPar
611
&&
\sphinxAtStartPar
7
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Logic Analyzer}
\label{\detokenize{linux/logic:logic-analyzer}}\label{\detokenize{linux/logic::doc}}
\sphinxAtStartPar
\sphinxurl{https://www.saleae.com/}

\sphinxAtStartPar
There is a way to sniff Canbus traffic using a logic analyzer.

\sphinxAtStartPar
On linux I installed the PulseView software.

\noindent\sphinxincludegraphics{{pulseview-how}.png}

\sphinxAtStartPar
\sphinxstyleemphasis{important remark : specify the canbus\sphinxhyphen{}speed : 125000 or 500000}

\noindent\sphinxincludegraphics{{logic-analyzer}.png}


\section{virtual box on linux}
\label{\detokenize{linux/vbox:virtual-box-on-linux}}\label{\detokenize{linux/vbox::doc}}
\sphinxAtStartPar
The software of the VIDA diagnostic tool is installed on windows 7.

\sphinxAtStartPar
The software comes as an oracle vbox and is a windows 7 image.

\sphinxAtStartPar
\sphinxstyleemphasis{installing this under ubuntu 22 proved challenging}


\subsection{the problem is USB 3}
\label{\detokenize{linux/vbox:the-problem-is-usb-3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
install the VirtualBox Extension Pack 7.0.12 (files/tools/extension pack manager)

\item {} 
\sphinxAtStartPar
sudo usermod \sphinxhyphen{}a \sphinxhyphen{}G vboxusers \$USER

\end{itemize}

\sphinxAtStartPar
\sphinxhyphen{}Win7: you need to install the “Intel USB 3.0 eXtensible Host Controller Driver” in your Windows 7 guest:
Update 2019\sphinxhyphen{}11\sphinxhyphen{}20: Intel seems to have removed the driver from its official site, you can get it from the Archive.org site: \sphinxurl{http://web.archive.org/web/201901092235} … Driver.zip
\begin{itemize}
\item {} 
\sphinxAtStartPar
now the SETEK dice adapter should be visible

\end{itemize}


\section{SavvyCAN}
\label{\detokenize{linux/savvyCAN:savvycan}}\label{\detokenize{linux/savvyCAN::doc}}
\sphinxAtStartPar
\sphinxurl{https://github.com/collin80/SavvyCAN}

\sphinxAtStartPar
I used a prebuild version, since compiling QT stuff is not my cup.

\sphinxAtStartPar
SavvyCAN\sphinxhyphen{}x86\_64.AppImage


\subsection{using socketcan}
\label{\detokenize{linux/savvyCAN:using-socketcan}}
\sphinxAtStartPar
recall :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
modprobe can
modprobe can\PYGZhy{}raw
modprobe slcan
slcand \PYGZhy{}s6 \PYGZhy{}S2000000 /dev/ttyACM1 can0
ifconfig can0 up
\end{sphinxVerbatim}


\subsection{howto configure savvycan for use with socketcan}
\label{\detokenize{linux/savvyCAN:howto-configure-savvycan-for-use-with-socketcan}}
\noindent\sphinxincludegraphics{{savvycan-config}.png}


\subsection{playback over socketcan}
\label{\detokenize{linux/savvyCAN:playback-over-socketcan}}
\noindent\sphinxincludegraphics{{savvycan-playback}.png}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}